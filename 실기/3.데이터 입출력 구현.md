### 31. 데이터 모델의 개념 - B

* 데이터 모델: 현실 세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 체계적으로 표현한 개념적 모형.
* 구성요소
  * 개체(Entity): 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체.
  * 속성(Attribute): 데이터의 가장 작은 논리적 단위. 파일 구조상 데이터 항목 또는 데이터 필드에 해당.
  * 관계(Relationship): 개체 간의 관계 또는 속성 간의 논리적 연결.
* 개념적 데이터 모델: 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정.
* 논리적 데이터 모델: 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있도록 변환하는 과정.
* 물리적 데이터 모델: 실제 컴퓨터에서 데이터가 저장되는 방법을 정의하는 물리 데이터베이스 설계 과정.
* 데이터 모델에 표시할 요소
  * 구조(Structure): 논리적으로 표현된 개체 타입들 간의 관계. 데이터 구조 및 정적 성질을 표현.
  * 연산(Operation): 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세. 데이터베이스를 조작하는 기본 도구.
  * 제약조건(Constraint): 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약조건.

---

### 32. 이상/함수적 종속/정규화 - A

* 이상(Anormaly): 테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 이로 인해 테이블 조작 시 문제가 발생하는 현상.
  * 삽입 이상(Insertion): 테이블에 데이터 삽입 시 원하지 않는 값들로 인해 삽입할 수 없게 되는 현상.
  * 삭제 이상(Deletion): 테이블에서 한 튜플 삭제 시 원하지 않는 값들까지 연쇄 삭제되는 현상.
  * 갱신 이상(Update): 테이블에서 튜플의 속성 값 갱신 시 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상.
* 함수적 종속(Functional Dependency): 어떤 테이블에서 속성A의 값에 대해 속성B의 값이 오직 하나만 연관되어 있을 때 B는 A에 함수적 종속이라 하고 A→B로 표기함. 이때 A를 결정자(Determinant), B를 종속자(Dependent)라고 함.
  * 예) 학번, 이름, 학년, 학과 속성으로 이루어진 테이블에서, 학번만 알면 이름, 학년, 학과를 알 수 있으므로 이름, 학년, 학과는 학번에 함수적 종속이다.
  * 완전 함수적 종속/부분 함수적 종속: 기본키인 속성 집합에 대해, 한 속성이 기본키에 대해서만 함수적 종속이라면 완전 함수적 종속이고, 만약 기본키의 부분집합에 대해서도 함수적 종속이라면 부분 함수적 종속이라고 함.
* 정규화(Normalization): 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용해 테이블을 무손실 분해하는 과정.
  * 제1정규형(1NF): 모든 **도**메인이 원자값. (테이블의 한 칸은 하나의 정보만 담음)
  * 제2정규형(2NF): **부**분적 함수 종속 제거. 즉 모든 속성이 완전 함수적 종속이 되도록 테이블을 쪼갬.
  * 제3정규형(3NF): **이**행적 함수 종속 제거. 한 테이블에서 A→B, B→C일 때, A→B인 테이블과 B→C인 테이블로 쪼갬.
  * BCNF: **결**정자이면서 후보키가 아닌 것 제거. A→B인데 A가 그 테이블에서 후보키가 아닐 때(즉 중복값이 있을 때) 테이블을 쪼갬.
  * 제4정규형(4NF): **다**치 종속을 제거. (다치 종속: C가 복합 속성(A,B)에 대해 A에만 종속이고 B에는 종속이 아닌 것)
  * 제5정규형(5NF): **조**인 종속성 이용.

---

### 33. 논리 데이터 모델의 물리 데이터 모델로 변환 - A

|        논리 데이터 모델        |  물리 데이터 모델   |
| :----------------------------: | :-----------------: |
|         엔티티(Entity)         |    테이블(Table)    |
|         속성(Atribute)         |    컬럼(Column)     |
| 주 식별자(Primary Identifier)  | 기본키(Primary Key) |
| 외부 식별자(Forein Identifier) | 외래키(Forein Key)  |
|       관계(Relationship)       | 관계(Relationship)  |

* 슈퍼타입과 서브타입을 테이블로 변환하는 방법
  * 슈퍼타입 기준 테이블 변환
  * 서브타입 기준 테이블 변환
  * 개별타입 기준 테이블 변환

---

### 34. 반정규화(Denormalization) - B

* 시스템 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정. 의도적으로 정규화 원칙을 위배하는 것.
  * 테이블 통합: 두 테이블을 조인하는 경우가 많을 때 테이블을 하나로 합치는 게 성능향상에 도움이 될 경우 수행.
  * 테이블 분할(Partitioning)
    * 수평 분할: 레코드를 기준으로 분할. 레코드별로 사용 빈도가 크게 차이날 경우.
    * 수직 분할: 속성을 기준으로 분할. 한 테이블에 속성이 너무 많을 경우.
  * 중복 테이블 추가: 여러 테이블에서 데이터를 추출해서 사용해야 하거나 다른 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가하여 작업 효율성 향상.
  * 중복 속성 추가: 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 추가하는 것.

---

### 35. 인덱스 - A

* 데이터 레코드에 빠르게 접근하기 위해 <키값, 포인터> 쌍으로 구성되는 데이터 구조.
* 인데스 키 순서에 따라 데이터가 정렬되어 저장되는 클러스터드 인덱스, 인덱스의 키값만 정렬된 넌클러스터드 인덱스 방식이 있음.
* 인덱스가 없으면 특정 값을 찾기 위해 모든 데이터를 순회하는 TABLE SCAN이 발생.
* 종류
  * 트리 기반 인덱스: 인덱스를 저장하는 블록들이 트리 구조를 이룸.
  * 비트맵 인덱스: 인덱스 컬럼의 데이터를 비트값인 0 또는 1로 변환하여 인덱스 키로 사용.
  * 도메인 인덱스: 개발자가 필요한 인덱스를 직접 만들어 사용.

---

### 36. 뷰 - A

* 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상의 테이블. 저장장치 내에 물리적으로 존재하지 않음. CREATE로 정의하고 DROP으로 제거. 
  * 장점: 데이터의 논리적 독립성 제공. 사용자의 데이터 관리를 간단하게 해줌.
  * 단점: 독립적 인덱스 못 가짐. 뷰의 정의를 변경 못함. 

---

### 37. 클러스터 - A

* 데이터 저장 시 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법. 클러스터링 키로 지정된 컬럼 값의 순서대로 저장되고 여러 테이블이 한 클러스터에 저장됨.
  * 조회속도는 향상시키지만 입력, 수정, 삭제 성능은 저하.
  * 처리 범위가 넓은 경우는 단일 테이블 클러스터링을, 조인이 많이 발생하는 경우에는 다중 테이블 클러스터링을 사용.
  * 분포도가 넓은 테이블, 대량의 범위를 자주 조회하는 테이블, 자주 조인되는 테이블 등이 적합.

---

### 38. 파티션 - A

* 대용량의 테이블이나 인덱스를 작은 논리적 단위로 나누는 것.
  * 장점: 쿼리 성능 향상. 디스크 성능 향상. 속도 빠름. 데이터 가용성 향상.
  * 단점: 세심한 관리 요구. 조인 비용 증가. 용량이 작은 테이블을 파티셔닝하면 성능 저하.
* 종류
  * 범위 분할(Range): 지정한 열의 값을 기준으로 분할.
  * 해시 분할(Hash): 해시 함수를 적용한 결과에 따라 분할.
  * 조합 분할(Composite): 범위 분할로 분할한 다음 해시 함수 적용.

---

### 39. 데이터베이스 용량 설계 - C

* 데이터가 저장될 공간을 정의함. 

* 순서

  1. 기초 자료 수집: 데이터 예상 건수, 로우 길이, 보존기간, 증가율 등

  2. 1을 바탕으로 DBMS에 이용될 테이블, 인덱스 등 오브젝트별 용량 산정
  3. 테이블과 인덱스의 테이블스페이스 용량 산정
  4. 데이터베이스에 저장될 모든 데이터 용량과 시스템 용량을 합해 디스크 용량 산정

