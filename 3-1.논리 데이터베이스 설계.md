### 70. 데이터베이스 설계 - A

* 고려사항
  * **무결성**: 저장된 데이터는 항상 제약조건을 만족
  * **일관성**: 데이터 간 혹은 질의에 대한 응답이 항상 일정
  * **회복**: 장애 발생 시 발생 직전으로 복구
  * **보안**: 불법적인 노출, 변겅, 손실로부터 보호
  * **효율성**: 응답시간 단축, 생산성, 저장공간 최적화
  * **확장성**: DB 운영에 영향을 안주면서 지속적으로 데이터 추가
* 순서
  * **요구 조건 분석**: 요구 명세서 작성
    * 사용자로부터 업무와 데이터 종류, 용도, 처리형태, 흐름, 제약조건 등을 파악
  * **개념적 설계**: 현실 세계에 대한 인식을 추상적 개념으로 표현(정보 모델링, 개념화)
    * **개념 스키마 모델링**, **트랜잭션 모델링**을 병행 수행함
    * 요구조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성
    * DBMS에 독립적인 **개념 스키마 설계**
  * **논리적 설계**: 현실 세계의 자료를 논리적 자료 구조로 변환하는 과정(데이터 모델링)
    * 개념 스키마를 평가 및 정제하고 DBMS에 따른 **논리적 스키마를 설계**하는 단계
    * **트랜잭션의 인터페이스**를 설계, (관계형 DB라면) 테이블 설계
  * **물리적 설계**: 논리적 데이터를 저장장치에 저장할 수 있게 물리적 구조의 데이터로 변환 (데이터 구조화)
    * 데이터베이스 파일의 저장구조 및 액세스 경로를 결정
    * 저장 레코드의 형식, 순서, 접근 경로 등의 정보로 데이터가 컴퓨터에 저장되는 방법을 정함
  * **구현**: 논리적, 물리적 설계 단계에서 도출된 스키마를 파일로 생성
    * DDL(데이터 정의어)을 이용해 DB 스키마 기술 후 컴파일하여 빈 DB 파일을 생성
    * 생성된 빈 DB 파일에 데이터 입력
    * 응용 프로그램을 위한 트랜잭션 작성, DB 접근을 위한 트랜잭션 작성

<br>

### 71. 데이터 모델의 개념 - B

* 데이터 모델: 현실 세계의 정보를 컴퓨터에 표현하기 위해 단순화, 추상화한 개념적 모형.
  * 구성요소: 개체, 속성, 관계
  * 종류: 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
  * 표시할 요소: 구조, 연산, 제약 조건
* 구성 요소
  * **개체(Entity)**: 데이터베이스에 표현하려는 현실 세계의 정보.
  * **속성(Attribute)**: 데이터의 가장 작은 논리적 단위로 파일 구조상 데이터 항목 또는 데이터 필드에 해당.
  * **관계(Relationship)**: 개체 간의 관계 또는 속성 간의 논리적인 연결.
* **개념적 데이터 모델**
  * 속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용해 현실 세계를 표현함
  * 현실 세계에 존재하는 개체를 인간이 이해할 수 있는 정보구조로 표현하기 때문에 정보 모델이라고도 함
  * 대표적으로 E-R 모델
* **논리적 데이터 모델**: 개념적 구조를 컴퓨터가 처리할 수 있는 구조로 변환하는 과정
  * 필드로 기술된 데이터 타입과 이 타입들 간 관계를 이용해 현실 세계를 표현함
  * 단순히 데이터 모델이라 하면 논리적 데이터 모델을 의미함
  * 특정 DBMS는 특정 논리적 데이터 모델 하나만 선정해서 사용
  * 데이터 간 관계의 표현방식에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분함
* 논리적 데이터 모델의 품질 검증: 정확성, 완전성, 준거성, 최신성, 일관성, 활용성
  * 개체: 
  * 속성: 
  * 관계: 
  * 식별자: 
  * 전반적: 
* 데이터 모델에 표시할 요소
  * **구조(Structure)**: 논리적으로 표현된 개체 타입들 간의 관계. 데이터 구조 및 정적 성질 표현.
  * **연산(Operation)**: DB에 저장된 실제 데이터를 처리하는 작업. DB를 조작하는 기본 도구.
  * **제약조건(Constraint)**: DB에 저장될 수있는 데이터의 논리적 제약 조건.

### 72. 개체(Entity) - A

* 특징
  * 실세계에 독립적으로 존재하는 유무형의 정보로 서로 연관된 속성들로 구성
  * 파일 시스템의 레코드에 해당
  * 영속적
  * 독립적으로 존재하거나 그 자체로 구별 가능
  * 업무 프로세스에 의해 이용됨
  * 다른 개체와 하나 이상의 관계가 있음

* 개체의 구성요소 (테이블로 비교)
  * 속성: column
  * 개체 타입: header
  * 개체 인스턴스: row (개체 Occurrence라고도 함)
  * 개체 세트: 모든 row
* 개체 선정 방법
  * 업무 기술서를 이용, 업무 담당자와 인터뷰
  * 실제 업무를 직접 견학하여 확인, 장부와 전표 이용
  * 이미 구축된 시스템의 산출물 검토
  * **자료 흐름도(DFD)**의 **자료 저장소(Data Store)**를 이용
  * **BPR(업무 프로세스 재설계)**에 의해 업무를 재정의한 경우 **관련 개체** 찾음
* 개체명 지정 방법
  * 업무 용어로 지정, 약어 자제, 가능하면 단수명사, 중복 안됨, 가능한 한 개체 생성 의미에 따라 부여함

<br>

### 73. 속성(Attribute) - B

* 특징
  * DB를 구성하는 가장 작은 논리적 단위
  * 파일 구조상 데이터 항목 또는 필드에 해당
  * 개체를 구성, 개체의 특성을 기술
  * 속성의 수를 차수(Degree)라고 함
* 특성에 따른 분류
  * 기본 속성(Basic): 업무 분석을 통해 정의함, 가장 일반적, 업무상 코드로 정의한 속성은 제외함
  * 설계 속성(Designed): 업무상엔 없고 설계 도중에 도출함, 데이터 모델링을 위해 **업무를 규칙화**할때 사용
  * 파생 속성(Derived): 다른 속성으로부터 영향을 받아 발생하는 속성, 되도록 적은게 좋음
* 구성 방식에 따른 분류
  * 기본키 속성(Primary Key): 개체를 식별할 수 있는 속성
  * 외래키 속성(Foreign Key): 다른 개체와 관계된 속성
  * 일반 속성: 나머지
* 속성 후보
  * 많을수록 좋음, 원시 속성(Source)인 속성 후보는 버리지 않음, 소그룹별로 속성 후보군을 만들고 가장 근접한 개체에 할당함
* 속성명 지정 원칙
  * 업무 용어로 지정, 서술형 X, 약어 자제, 개체명 X, 개체 내에서 중복 X

<br>

### 74. 관계(Relationship) - B

* 관계에는 개체 간 관계와 속성 간 관계가 있음

* 형태: 일대일(1:1), 일대다(1:N), 다대다(N:M)
* 종류
  * **종속 관계(Dependent)**: 두 개체간 주종관계를 표현
    * 식별 관계: A의 기본키가 B의 외래키이자 기본키
    * 비식별 관계: A의 기본키가 B의 비기본키
  * **중복 관계(Redundante)**:  두 개체간 2번 이상의 종속 관계가 발생한 관계
  * **재귀 관계(Recursive)**: 개체가 자기 자신과 관계를 가짐 (=순환 관계)
  * **배타 관계(Exclusive)**: 개체의 속성이나 식별자를 기준으로 개체의 속성을 분할하는 관계
    * 배타 AND 관계: 하위 개체 중 하나만 선택
    * 배타 OR 관계: 하나 이상의 개체 선택

<br>

### 75. 식별자(Identifier) - C

* 식별자: 개체 내에서 각각의 인스턴스를 Unique하게 구분하는 구분자
* **주/보조 식별자(Primary/Alternate)**: 대표성 여부
  * 둘다 개체를 유일하게 식별할 수 있어야 함
  * 한 개체에 주 식별자는 1개만, but 보조 식별자는 여러개 존재 가능
  * 개체를 유일하게 식별할 수 있는 식별자가 둘 이상인 경우 업무에 적합한 것을 주, 나머지를 보조로 함
  * 물리적 테이블에서 주 식별자는 기본키, 보조 식별자는 Unique Index로 지정됨
  * 주 식별자 특징: 유일성, 최소성(속성 수 최소), 불변성, 존재성(NULL 안됨)

* **내부/외부 식별자(Internal/Foreign)**: 스스로 생성 여부

  * 내부 식별자: 개체 내에서 만들어짐
  * 외부 식별자: 다른 개체와의 관계에 의해 외부 개체의 식별자를 가져와 사용, 다른 개체를 찾아가는 연결자 역할

* **단일/복합 식별자(Single/Composit)**: 단일 속성 여부

  * 단일 식별자: 주 식별자가 한 가지 속성으로만 구성됨
  * 복합 식별자: 주 식별자가 두 개 이상 속성으로 구성됨

* **원조/대리 식별자(Original/Surrogate)**: 대체 여부

  * 원조 식별자: 업무에 의해 만들어진 가공되지 않은 원래 식별자 (=본질 식별자)
  * 대리 식별자: 주 식별자의 속성이 2개 이상인 경우 속성들을 하나로 묶어 사용하는 식별자 (=인조 식별자)

  * 대리 식별자의 조건: 범용적인 값 사용, 유일한 값 만들기, 하나의 대리 식별자 속성으로 대체할 수 없는 경우를 주의, 편의성, 단순성, 의미의 체계화, 시스템적인 필요성에 의해 내부적으로만 사용하는 대리 식별자

* **후보 식별자**
* 각 인스턴스를 유일하게 식별할 수 있는 속성 또는 속성 집합(주 + 보조 식별자)
  * 속성들을 직접 식별 가능해야 함, NULL 값이 될 수 없음, 자주 변경되면 안됨, 속성 집합은 개념적으로 유일해야 함

<br>

### 76. E-R(Entity-Relationship) 모델 - A

* 특징
  * 개체 타입과 이들 간의 관계 타입을 이용해 표현, 데이터를 개체, 관계, 속성으로 표현함
  * 특정 DBMS를 고려한 건 아님
  * 다이어그램으로 나타내며 일대일, 일대다, 다대다를 제한 없이 표현가능

* **피터 첸 표기법**
  * 개체-사각형, 관계-마름모, 속성-타원, 밑줄-기본키
* **정보 공학 표기법**
  * 박스 위에 개체명, 박스 내 첫칸에 기본키를 씀
  * |(필수), ○(선택적), <(다중)으로 관계 표현
* **바커 표기법**
  * 박스 첫칸에 개체명, #-기본키, *-속성, O-속성(NULL가능)
  * ―(필수), …(선택적), <(다중)으로 관계 표현

<br>

### 77. 관계형(Relational) 데이터 모델 - C

* **기본키**와 이를 참조하는 **외래키**로 데이터 간의 관계를 표현
* **개체를 테이블(릴레이션)로 사용**하고 개체 간 관계를 공통 속성으로 연결
* 계층 모델과 망 모델을 단순화시킨 모델
* 대표적으로 SQL

<br>

### 78. 관계형 데이터베이스의 구조 - A

* 개체나 관계를 모두 릴레이션(표)로 표현, 개체 릴레이션과 관계 릴레이션 존재
  * 장점: 간결하고 보기 편함, 다른 DB로 변환 용이
  * 단점: 성능이 다소 떨어짐
* 구조
  * **튜플**: Row, 속성의 모임, 레코드, 튜플의 수를 기수(Cardinality)라고 함
  * **속성**: Column, 필드, 속성의 수를 차수(Degree)라고 함
  * **도메인**: 한 속성이 취할 수 있는 같은 타입의 값들의 집합
  * 릴레이션 스키마: Columns, 릴레이션 인스턴스(어커런스): Rows, 릴레이션 = 스키마 + 인스턴스

* 특징
  * 모든 튜플은 중복되지 않음
  * 튜플 간에는 순서가 없음
  * 튜플의 삽입, 삭제 등으로 인해 릴레이션은 시간에 따라 변함
  * 스키마를 구성하는 속성들 간 순서도 중요X
  * 속성의 명칭은 유일하지만 값은 동일할 수 있음
  * 속성들의 부분집합을 Key로 설정
  * 속성의 값은 논리적으로 더이상 쪼갤 수 없는 값만 저장

<br>

### 79. 관계형 DB 제약조건 - 키(Key) - A

* 키: DB에서 조건에 맞는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성

* **후보키(Candidate)**: 튜플을 유일하게 식별할 수 있는 키, 기본키로 사용 가능한 속성들.
  * **유일성(Unique)**, **최소성(Minimality)**을 가져야 함
* **기본키(Primary)**: 후보키 중에서 선정된 Main Key. NULL값을 가질 수 없음.
* **대체키(Alternate)**: 기본키가 아닌 후보키.
* **슈퍼키(Super)**: 속성들의 집합으로 이뤄진 키. 유일성은 만족하지만 최소성은 만족못함.
* **외래키(Foreign)**: 다른 릴레이션의 기본키를 참조하는 속성 또는 속성의 집합. 

### 80. 관계형 DB 제약조건 - 무결성 - B

* **무결성(Integrity)**: DB의 데이터와 현실의 실제 값이 일치하는 정확성. 무결성 제약 조건은 데이터의 정확성을 보장하고 부정확한 데이터가 저장되는 것을 방지.
* **개체 무결성(Entitiy, 실체 무결성)**: 기본키 속성은 Null값이나 중복값을 가질 수 없음.
* **도메인 무결성(Domain, 영역 무결성)**: 주어진 속성의 값이 정의된 도메인에 속한 값이어야 함.
* **참조 무결성(Referential)**: 외래키의 값은 Null 아니면 참조 릴레이션의 기본키 값이어야 함. 즉 참조할 수 없는 외래키 값을 가질 수 없음.
* **사용자 정의 무결성(User-Defined)**: 속성 값들이 사용자가 정의한 제약조건을 만족해야 함.
* 데이터 무결성 강화: 데이터 특성에 맞는 적절한 무결성을 정의하고 강화해야 함.
  * 프로그램 완성 후 정의하면 많은 비용이 발생하므로 데이터베이스 구축 과정에 정의해야 함.
  * 애플리케이션: 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 추가함, 복잡한 규칙은 애플리케이션 내에서 처리함.
    * 장점: 사용자 정의 같은 복잡한 무결성 조건을 구현 가능
    * 단점: 소스코드에 분산되어 있어 관리가 힘들고 적정성 검토가 어려움.
  * 데이터베이스 트리거: 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가함.
    * 장점: 통합 관리 가능, 복잡한 조건 구현 가능.
    * 단점: 운영 중 변경 어려움, 사용상 주의 필요.
  * 제약 조건: 데이터베이스에 제약 조건을 설정.
    * 장점: 통합 관리 가능, 간단한 선언으로 구현 가능, 변경 용이, 오류 데이터 발생 방지
    * 단점: 복잡한 제약 조건의 구현과 예외 처리가 불가능.

<br>

### 81. 관계대수 및 관계해석 - A

* **관계대수**: DB에서 원하는 정보를 검색하기 위한 절차적인 언어. 릴레이션을 처리하기 위한 연산자를 제공. 피연산자와 결과물은 릴레이션. 연산의 순서를 명시.
  * 순수 관계 연산자: 관계형 DB에 적용시키기 위해 개발된 연산자. Select, Project, Join, Division 등
  * 일반 집합 연산자: 수학적 집합 이론에서 쓰는 연산자. UNION, INTERSECTION, DIFFERENCE, CARTESIAN PRODUCT 등
* **Select**: 선택 조건을 만족하는 튜플의 부분집합을 구함. 수평 연산이라고도 함.
  * σ<조건> (R): 릴레이션에서 조건에 맞는 튜플을 추출
* **Project**: 속성 리스트에 제시된 속성만을 추출. 결과에 중복이 있으면 중복을 제거함. 수직 연산.
  * π<속성1,속성2...> (R): 릴레이션에서 해당 속성만 추출
* **Join**: 공통 속성을 중심으로 두 릴레이션을 하나로 합쳐 새로운 릴레이션을 만듦. 교차곱 후 Select를 수행한 것과 같음.
  * R ▷◁ 키속성r=키속성s S: 속성명이 동일하면 S의 속성명은 'S.키속성'과 같은 식으로 남게 됨.
  * R ▷◁ 키속성 S: 자연 조인. 두 릴레이션을 조인할 때 속성명과 도메인이 같다면 중복을 제거하고 조인.
* **Division**: X ⊃ Y인 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산.
  * R[속성r ÷ 속성s]S
* 일반 집합 연산자
  * UNION(합집합), INTERSECTION(교집합), DIFFERENCE(교집합), CARTESIAN PRODUCT(교차곱)
  * 교차곱의 결과는 **차수(Degree)는 더하고 기수(Cardinality)는 곱함**.
* 관계해석(Relational Calculus): 관계 데이터의 연산을 표현하는 방법. 원하는 정보가 무엇이라는 **비절차적** 특징을 지님. **튜플 관계해석**과 **도메인 관계해석**이 있음. 기본적으로 관계대수와 동등하며 관계대수로 표현한 식은 관계해석으로 표현가능. 질의어로 표현.

<br>

### 82. 정규화(Normalization) - A

* 정규화: 데이터의 중복성을 최소화하고 일관성을 보장하기 위해 수행. DB의 논리적 설계 단계에서 수행. 일관성, 정확성, 단순성, 비중복성, 안정성 등을 보장. 정규화 수준이 높을수록 유연한 데이터 구축이 가능하고 데이터 정확성은 높아지지만 물리적 접근이 복잡해지고 조회 성능 저하됨.
* 목적
  * 데이터 구조의 안정성 및 무결성 유지.
  * 어떠한 릴레이션이든 데이터베이스 내에서 표현 가능하게 함.
  * 효과적인 검색 알고리즘 생성 가능.
  * 중복 배제하여 이상(Anomaly) 방지 및 자료 저장 공산의 최소화 가능.
  * 데이터 삽입 시 릴레이션 재구성할 필요성 줄임.
  * 데이터 모형의 단순화 가능.
  * 속성의 배열 상태 검증 가능.
  * 개체와 속성의 누락 여부 확인 가능. 
  * 자료 검색과 추출의 효율성 추구.
* **이상(Anomaly)**: 속성 간 종속 혹은 데이터의 중복으로 발생.
  * 삽입 이상: 데이터 삽입 시 원하지 않는 값들도 삽입되는 현상.
  * 삭제 이상: 한 튜플을 삭제할 때 원하지 않는 튜플도 삭제되는 현상.
  * 갱신 이상: 튜플의 속성값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 모순이 생기는 현상.
* 정규화의 원칙
  * 정보의 무손실 표현(스키마 변환 시 정보손실 X), 분리의 원칙(독립된 관계성은 독립된 릴레이션으로), 데이터 중복성 감소
* 정규화 과정
  * **1NF(제1정규형)**: 모든 도메인이 원자값으로 구성 -> 릴레이션의 모든 속성이 단순 영역에서 정의됨.
  * **2NF(제2정규형)**: 1NF를 만족하고 기본키가 아닌 모든 속성이 기본키에 대해 완전 함수적 종속을 만족함.
    * 즉 기본키의 각 속성만으로 모든 값을 식별할 수 있도록 테이블을 쪼갬.
  * **3NF(제3정규형)**: 2NF를 만족하고 기본키가 아닌 모든 속성이 기본키에 대해 이행적 종속을 만족하지 않음.
    * 즉 기본키 이외의 다른 속성으로 값을 식별할 수 없도록 테이블을 쪼갬.
  * **BCNF(Boyce-Codd 정규형)**: 결정자가 모두 후보키인 정규형. 키가 아닌 모든 속성은 각 키에 완전 종속해야 함. 어떤 속성도 키가 아닌 속성에 완전 종속할 수 없음.
  * **4NF(제4정규형)**: 다치 종속
  * **5NF(제5정규형, PJ/NF)**: 모든 조인 종속이 릴레이션의 후보키를 통해서만 성립
  * 정규화 과정
    * 비정규 릴레이션 -> (도메인이 원자값) -> 1NF -> (부분적 함수 종속 제거) -> 2NF -> (이행적 함수 종속 제거) -> 3NF -> (결정자이면서 후보키가 아닌 것 제거) -> BCNF -> 다치 종속 -> 4NF -> 조인 종속성 이용 -> 5NF (**도부이결다조**)

<br>

### 83. 반정규화(Denomalization) - B

* 반정규화: 성능향상, 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정. 과도한 반정규화는 성능을 저하시킬수도 있음.
  * **테이블 통합**: 두 테이블이 조인되는 경우가 많아 그냥 하나로 합치는 것. 1:1, 1:N, 슈퍼타입/서브타입 등
    * Not Null, Defalut, Check 등의 제약조건을 설계하기 어려움. 입력, 수정, 삭제 규칙이 복잡해질 수 있음.
  * **테이블 분할**: 테이블을 수직 혹은 수평으로 분할.
    * 수평 분할: 레코드를 기준으로 분할. 레코드별로 사용 빈도 차이가 큰 경우 빈도에 따라 분할함.
    * 수직 분할: 속성을 기준으로 분할. 갱신 위주, 조회 위주, 크기 위주, 보안 위주로 분할 가능.
    * 기본키의 **유일성** 관리가 어려워짐. 데이터 검색에 중점을 두어 분할 여부를 결정해야 함.
  * **중복 테이블 추가**: 정규화로 수행속도가 느려질 경우, 많은 범위 데이터를 자주 처리할 경우, 특정 범위 데이터만 자주 처리할 경우, 처리 범위를 줄여야만 속도가 개선될 경우
    * 집계 테이블의 추가: 각 원본에 트리거를 설정해 사용, 트리거의 오버헤드에 유의
    * 진행 테이블의 추가: 이력 관리 등의 목적, 기본키를 적절히 설정
    * 특정 부분만 포함하는 테이블 추가: 데이터가 많은 테이블의 특정 부분만을 사용하는 경우
  * **중복 속성 추가**: 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것. 접근경로가 복잡한 속성, 액세스의 조건으로 자주 사용되는 속성, 기본키가 적절하지 않거나 여러개로 구성된 경우
    * 테이블과 속성의 중복 고려, **일관성**과 **무결성** 유의, SQL 그룹 함수를 이용해 처리가능해야 함, 지나친 저장공간 낭비 고려

<br>

### 84. 시스템 카탈로그 - A

* **시스템 카탈로그**: 시스템 그 자체에 관련이 있는 다양한 객체의 정보를 포함하는 시스템 데이터베이스.
  * 사용자를 포함해 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블임. 좁은 의미로는 카탈로그를 데이터 사전이라고도 함.

* 저장 정보: 시스템 카탈로그에 저장된 정보를 **메타 데이터**라고 함.
  * 데이터베이스 객체 정보: 테이블, 인덱스, 뷰 등의 구조 및 통계 정보.
  * 사용자 정보: 아이디, 패스워드, 접근 권한 등.
  * 테이블의 무결성 제약 정보: 기본키, 외래키, NULL 값 허용 여부 등.
  * 함수, 프로시저, 트리거 등에 대한 정보.
* 특징
  * 카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 이용자도 SQL로 검색 가능. INSERT, DELETE, UPDATE 문으로 갱신은 못함.
  * DB 시스템에 따라 상이한 구조. 카탈로그는 DBMS가 스스로 생성하고 유지함. (자동 갱신)
  * 분산 시스템에서의 카탈로그: 보통의 릴레이션, 인덱스, 사용자 정보 등의 정보를 포함할 뿐 아니라 위치 투명성 및 중복 투명성을 제공하기 위해 필요한 모든 제어 정보를 가져야 함.
* 카탈로그/데이터 사전을 참조하기 위한 DBMS 내의 모듈 시스템
  * 데이터 정의어 번역기(DDL Compiler): DDL을 카탈로그로 변환하여 데이터 사전에 저장
  * 데이터 조작어 번역기(DML Compiler): 응용 프로그램에 삽입된 DML문을 주 언어로 표현한 프로시저 호출로 변환하여 질의 처리기와 상호 통신함
  * **Data Directory**: 데이터 사전에 수록된 데이터에 접근하는 데 필요한 정보를 관리 유지하는 시스템
    * 시스템 카탈로그는 사용자, 시스템 모두 접근 가능하지만 데이터 디렉터리는 시스템만 접근 가능
  * 질의 최적화하기
  * 트랜잭션 처리기: 복수 사용자에 의한 동시 트랜잭션을 해결하여 각 사용자가 DB 자원을 배타적으로 이용할 수 있도록 함

<br>

