### 49. 애플리케이션 테스트 - B

* 소프트웨어 분류
  * 상용 소프트웨어: 일반 사용자들이 필요로 하는 기능 구현
    * 산업 범용: 시스템 소프트웨어, 미들웨어, 응용 소프트웨어
    * 산업 특화: 특정 분야에서 요구하는 기능만을 구현
  * 서비스 제공 소프트웨어: 특정 사용자가 필요로 하는 기능만 구현, 판매 X
    * 신규 개발, 기능 개선, 추가 개발, 시스템 통합
* 애플리케이션 테스트 필요성
  * 오류 예방, 신뢰도 향상, 개발 초기부터 해야함, 최소한의 시간과 노력으로 많은 결함 찾음
* 애플리케이션 테스트 기본 원리
  * 대부분 결함이 특정 모듈에 집중됨(파레토 법칙)
  * 동일한 테스트 케이스로 테스트를 반복하면 결함이 발견되지 않는 살충제 패러독스 발생하기도
  * 테스트 결과는 정황에 따라 달라질 수 있음(정황Context에 의존)
  * 결함을 모두 제거해도 사용자 요구사항을 만족시키지 못하면 안됨 (오류-부재의 궤변)
  * 테스트는 작은 부분에서 시작해 점점 확대해야 함, 개발자와 관계없는 별도 팀에서 수행해야 함

<br>

### 50. 애플리케이션 테스트 분류 - B

* 프로그램 실행 여부에 따른 테스트

  * 정적 테스트: 실행 없이 명세서나 소스코드를 분석. 개발 초기에 결함 발견. 워크스루, 인스펙션, 코드 검사 등.
  * 동적 테스트: 실행해서 오류를 찾음. 개발의 모든 단계에서 가능. 블랙박스 테스트, 화이트박스 테스트

* 테스트 기반(Test Bases)에 따른 테스트

  * 구조 기반 테스트: 논리 흐름에 따라 테스트 케이스 작성. (화이트박스) 구문 기반, 결정 기반, 조건 기반 등
  * 명세 기반 테스트: 요구사항을 전부 테스트 케이스로 만들어 확인. (블랙박스) 동등 분할, 경계 값 분석 등
  * 경험 기반 테스트: 유사 소프트웨어나 기술 등에 대한 테스터 경험을 기반. 명세가 불충분하거나 테스트 시간에 제약이 있을 경우 수행. 에러 추정, 체크리스트, 탐색적 테스팅

* 시각에 따른 테스트

  * 검증(Verification) 테스트: 개발자 시각. 명세대로 완성됐는지 테스트.
  * 확인(Validation) 테스트: 사용자 시각. 사용자 요구사항이 동작하는지 테스트.

* 목적에 따른 테스트

  * 회복(Recovery) 테스트
  * 안전(Security) 테스트
  * 강도(Stress) 테스트: 과부하 시에도 정상 작동하는지 테스트.
  * 성능(Perfomance) 테스트: 응답시간, 처리량 등을 테스트.
  * 구조(Structure) 테스트: 논리적 경로, 소스 복잡도 등을 테스트.
  * 회귀(Regression) 테스트: 수정된 코드에 새로운 결함이 없는지 확인하는 테스트.
  * 병행(Parallel) 테스트: 변경된 것과 기존 것에 동일한 데이터를 입력해 결과를 비교하는 테스트.

  <br>

### 51. 테스트 기법에 따른 애플리케이션 테스트 - A

* **화이트박스 테스트**: 비기능적 요구사항. 구조기반 테스트. 코드의 논리적인 모든 경로를 테스트하여 테스트케이스 설계. 테스트 과정의 초기에 적용. 

  * 종류
    * 기초 경로 검사: 절차적 설계의 논리적 복잡성 측정.
    * 제어 구조 검사: 조건 검사(논리적 조건 테스트), 루프 검사(반복구조에 초점을 두고 테스트), 데이터 흐름 검사(변수의 정의와 사용에 초점을 두고 테스트)
  * 검증 기준
    * 문장 검증 기준: 모든 구분이 수행되도록 설계
    * 분기 검증 기준: 모든 조건문이 수행되도록 설계
    * 조건 검증 기준: 모든 조건문이 True인 경우와 False인 경우가 수행되도록 설계
    * 분기/조건 기준: 모든 조건문과 각 조건문에 포함된 개별 조건식 결과가 True/False인 경우가 수행되도록 설계

* 검증 기준의 종류

  * 기능 기반 커버리지: 테스트 기능 수 / 전체 기능 수
  * 라인 커버리지: 테스트된 소스코드 라인 수 / 전체 라인 수
  * 코드 커버리지: 소스코드의 구분, 분기, 조건 등이 얼마나 테스트됐는지 확인 (화이트박스 테스트)

* **블랙박스 테스트**: 기능적 요구사항. 명세기반 테스트. 요구사항 명세를 보며 기능의 작동 테스트.  소프트웨어 인터페이스에서 실시. 테스트 과정의 후반부에 적용.

  * 종류
    * 동치 분할 검사: 입력 자료에 초점. 타당한 입력과 타당하지 않은 입력을 동등하게. 입력에 맞는 결과가 나오는지 확인.
    * 경계값 분석: 입력 조건의 경계값을 테스트 케이스로 선정. 동치 분할을 보완.
    * 원인-효과 그래프 검사: 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 분석.
    * 오류 예측 검사: 경험과 감각으로 테스트. 다른 기법으로 찾을 수 없는 오류를 찾는 기법.
    * 비교 검사: 여러 버전의 프로그램에 동인한 테스트 자료 제공.

  <br>

### 52. 개발 단계에 따른 애플리케이션 테스트 - A

1. **단위 테스트**: 코딩 직수 모듈이나 컴포넌트에 초점을 맞춰 테스팅. 사용자 요구사항을 기반으로 한 기능성 테스트를 최우선으로. 구조 기반과 명세 기반으로 나뉘지만 주로 구조 기반. 
2. **통합 테스트**: 단위 테스트가 완료된 모듈을 결합시키는 과정에서 테스트. 모듈 간 또는 컴포넌트 간 상호작용 검사.
3. **시스템 테스트**: 실사용환경과 비슷한 환경에서 테스트. 기능적/비기능적 요구사항을 각각 만족하는지 테스트.
4. **인수 테스트**: 사용자 요구사항 충족에 중점을 둔 테스트. 문제가 없으면 프로젝트 종료.
   * 사용자 인수 테스트, 운영상의 인수 테스트(시스템 관리자), 계약 인수 테스트, 규정 인수 테스트, 알파 테스트(사용자가 개발자 앞에서, 통제된 환경), 베타 테스트(선정된 사용자, 개발자에게 제어되지 않음)

<br>

### 53. 통합 테스트 - A

* 방식
  * 비점진적 통합방식: 모든 모듈이 결합된 프로그램 전체를 테스트. 소규모에 적합하고 단시간에 가능. 오류 발견 및 장애 위치 파악 어려움.
  * 점진적 통합방식: 모듈을 단계적으로 통합. 하향식, 상향식, 혼합식이 있음. 인터페이스 관련 오류를 완전히 테스트할 가능성 높음.
* **하향식 통합 테스트**: 주요 제어 모듈을 기준으로 아래 단계로 이동하며 통합. **깊이 우선**과 **넓이 우선**이 있음. **테스트 초기부터 시스템 구조 보여줌**. 상위 모듈에서는 테스트케이스를 사용하기 어려움.
  1. 주요 모듈은 작성된 프로그램을, 종속 모듈은 **스텁**(Stub, 일시적으로 필요한 조건만 가진 시험용 모듈)으로 대체.
  2. 깊이 또는 넓이 우선 방식에 따라 스텁이 하나씩 실제 모듈로 교체.
  3. 모듈이 통합될 때마다 테스트.
  4. 새 오류가 있는지 확인하기 위해 회귀 테스트 시행.
* **상향식 통합 테스트**: 스텁은 필요없지만 하나의 주요 모듈과 관련된 종속 모듈의 그룹인 클러스터(Cluster)가 필요. 
  1. 하위 모듈들을 **클러스터**로 결합.
  2. 상위 모듈과의 입출력을 확인하기 위한 더미 모듈인 **드라이버**(Driver)를 작성.
  3. 통합된 클러스터 단위로 테스트.
  4. 테스트 완료되면 클러스터는 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체.

* **혼합식 통합 테스트**: 상향식 + 하향식. 샌드위치식이라고도 함.

<br>

### 54. 애플리케이션 테스트 프로세스 - B

* 테스트를 마치면 아래가 산출됨:
  * 테스트 계획서
  * 테스트 케이스
  * 테스트 시나리오: 여러 개의 테스트 케이스의 동작 순서를 기술한 문서
  * 테스트 결과서: 테스트 결과를 비교 분석

1. 테스트 계획: 시작, 종료 조건
2. 테스트 분석: 테스트 데이터, 테스트 환경, 테스트 도구 준비
3. 테스트 케이스 및 시나리오 작성: 테스트 스크립트 작성
4. 테스트 수행: 테스트 환경 구축 후 테스트 수행
5. 테스트 결과 평가 및 리포팅: 결함을 중점적으로 기록. 결과에서 실행 절차를 최적화해 다음 테스트에 적용
6. 결함 추적 및 관리: 에러 발견 -> 에러 등록 -> 에러 분석 -> 결함 확정 -> 결함 할당 -> 결함 조치 -> 검토 및 승인

<br>

### 55. 테스트 케이스/테스트 시나리오/테스트 오라클 - B

* 테스트 케이스: 요구사항을 충족하는지 확인하기 위해 입력값, 실행조건, 기대값으로 구성된 명세서. 명세 기반 테스트의 설계 산출물. 이상적인 테스트 케이스는 시스템 설계 시 작성해야 함.
  * 작성 순서: 테스트 계획 검토 및 자료확보 -> 위험 평가 및 우선순위 결정 -> 요구사항 정의 -> 테스트 구조 설계 및 방법 설정 -> 테스트 케이스 정의 -> 테스트 케이스 타당성 확인 및 유지보수
* 테스트 시나리오: 적용 순서에 따라 테스트 케이스를 묶은 것. 
  * 작성 시 유의사항: 여러 시나리오로 분리해야 함, 요구사항과 설계 등을 토대로 작성해야 함
* 테스트 오라클: 사전에 정의된 참값을 대입하여 비교하는 기법
  * 모든 테스트케이스에는 적용X, 수학적 기법, 자동화 가능
  * 종류
    * 참 오라클: 모든 테스트 케이스 입력값에 대해 기대결과를 제공하는 오라클.
    * 샘플링 오라클: 특정 몇몇 테스트 케이스 입력 값들에 대해서만 기대결과를 제공하는 오라클.
    * 추정 오라클: 특정 테스트 케이스의 입력값에는 기대하는 결과를 제공하고 나머지 입력값에는 추정으로 처리하는 오라클.
    * 일관성 검사 오라클: 애플리케이션 변경 전후로 결과값이 동일한지 확인하는 오라클.

<br>

### 56. 테스트 자동화 도구 - B

* 유형
  * 정적 분석 도구: 프로그램 실행 없이 분석하는 도구. 테스터가 소스코드를 이해하고 있어야 함.
  * 테스트 실행 도구: 스크립트언어로 테스트 실행. 데이터 주도, 키워드 주도.
  * 성능 테스트 도구: 처리량, 시간, 자원 사용률 등을 테스트.
  * 테스트 통제 도구: 테스트 계획, 관리, 수행, 결함관리. 형상관리도구와 결합추적/관리도구가 있음.
  * 테스트 하네스 도구: 테스트를 지원하기 위해 생성된 코드와 데이터.
    * 드라이버, 스텁, 슈트(순서 없는 테스트케이스 묶음), 케이스, 스크립트, 목 오브젝트(사용자 행위를 조건부로 입력해두면 예정된 행동 수행)

* 수행 단계별 테스트 자동화 도구
  * 테스트 계획: 요구사항 관리
  * 테스트 분석: 테스트 케이스 생성
  * 테스트 수행: 테스트 자동화, 정적 분석, 동적 분석, 성능 테스트, 모니터링
  * 테스트 관리: 커버리지 분석, 형상 관리, 결합 추적/관리

<br>

### 57. 결함 관리 - B

* 결함: 예상 결과와 실행 결과 차이, 업무 내용과의 불일치 등 모두 포함
* 결함 관리 프로세스

  1. 결함 관리 계획
  2. 기록: 발견된 결함을 DB에 등록
  3. 검토
  4. 수정
  5. 재확인
  6. 결함 상태 추적
  7. 최종 결함 분석 및 보고서 작성

* 결함 상태 추적: 발견된 결함에 결함 관리 측정 지표를 분석해 향후 결함이 일어난 모듈을 추정함
  * 결함 분포(특정 모듈 또는 컴포넌트), 결함 추세(시간에 따른 결함수), 결함 에이징(결함 상태로 지속시간)
* 결함 추적 순서
  * 등록
  * 검토
  * 할당: 수정을 위해 개발자와 문제 해결 담당자에게 결함이 할당됨
  * 수정
  * 조치 보류: 결함의 수정이 불가능해 연기됨
  * 종료: 테스터와 품질 관리 담당자가 종료 승인
  * 해제
* 결함 분류
  * 시스템 결함: 시스템 다운, 작동 정지, 종료, 응답지연, DB에러
  * 기능 결함: 요구사항 미반영, 부정확한 프로세스, 오류, 타 시스템과 연동시 오류
  * GUI 결함: UI 비일관성, 데이터타입 표시오류, 부정확한 커서/메세지
  * 문서 결함: 매뉴얼의 불일치 등
* 결함 심각도: High(프로세스 진행불가), Medium(시스템 흐름에 영향), Low(시스템 흐름에 영향을 안미치는 결함)
* 결함 우선순위: 일반적으로 심각도가 높으면 우선순위도 높지만 애플리케이션 특성에 따라 변경될 수 있음.
* 결함 관리도구
  * Mantis: 단위별 작업내용 기록 가능
  * Trac: 결함 통합 관리
  * Redmine: 프로젝트 관리 및 결함 추적
  * Bugzilla: 결함 신고, 확인, 처리 등. 심각도와 우선순위 지정 가능

<br>

### 58. 애플리케이션 성능 분석 - C

* **지표**: 처리량, 응답시간, 경과시간, 자원 사용률
* 성능 테스트 도구
  * JMeter: HTPP, FTP 등 지원. 크로스플랫폼.
  * LoadUI: HTTP, JDBC 등 지원. 서버 모니터링. 드래그앤드롭으로 편리성 강화. 크로스플랫폼.
  * OpenSTA: HTTP, HTTPS 지원. 부하 테스트 및 생산품 모니터링. 윈도우.
* 시스템 모니터링 도구
  * Scouter: 튜닝 최적화. 애플리케이션 성능 모니터링
  * Zabbix: 웹기반 서버, 서비스, 애플리케이션 모니터링
* **성능 저하 원인**
  * DB에 필요 이상의 많은 데이터 요청
  * DB Lock 해제를 기다림
  * 커넥션 풀이 너무 크거나 작음
  * 미들웨어 사용 후 종료하지 않아 연결 누수 발생
  * 트랜잭션이 Commit되지 않고 반환되거나 코드 실수로 불필요한 Commit이 자주 발생
  * 대량의 파일을 업로드 혹은 다운로드
  * 트랜잭션 중 외부 호출이 장시간 수행
  * 네트워크 장비 간 데이터 전송 실패

<br>

### 59. 애플리케이션 성능 분석 - C

* 클린 코드 원칙
  * 가독성
  * 단순성: 클래스/메소드/함수를 최소단위로 분리.
  * 의존성 배제
  * 중복성 최소화
  * 추상화

* 소스 코드 최적화 유형
  * 클래스 분할 배치: 한 클래스는 하느의 역할만 수행. 크기를 작게.
  * 느슨한 결합: 인터페이스 클래스를 이용한 추상화된 자료구조와 메소드를 구현
  * 코딩형식 준수: 줄바꿈, 유사성 높은 종속함수, 호출하는 함수는 선배치, 호출되는 함수는 후배치, 지역변수는 각 함수의 맨 처음에 선언
  * 명명규칙 준수, 좋은 이름 사용
  * 적절한 주석
* 소스코드 품질 분석 도구
  * 정적 분석 도구: 코드를 실행하지 않고 코딩 표준, 스타일, 결함 등을 확인. 
  * 동적 분석 도구: 코드에 존재하는 메무리누수, 스레드 결함 등을 분석. Avalanche, Valgrind 등