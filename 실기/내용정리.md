## 1.프로그래밍 언어 활용 

* 객체지향 프로그래밍(OOP): 현실세계의 개체(Entity)를 객체로 만들어, 부품을 조립하듯 객체를 조립하여 프로그램을 작성할 수 있도록 한 프로그래밍 기법.

  * 구성요소
    * 객체: 데이터(속성)와 이를 처리하는 연산(메소드)을 결합시킨 실체.
    * 클래스: 둘 이상의 유사한 객체를 묶어 하나의 공통된 특성을 표현하는 요소.
    * 메세지: 객체 간 상호작용 수단. 
  * 특징
    * 캡슐화: 속성과 메소드를 하나로 묶음. 재사용 용이.
    * 정보 은닉: 다른 객체에 자신의 정보를 숨기고 연산만을 통해 접근.
    * 추상화: 객체의 중요한 속성만 간략하게 나타내어 슈퍼클래스를 선정.
    * 상속성: 정의된 부모 클래스의 속성과 메소드를 자식 클래스가 물려받음.
    * 다형성: 동일한 이름의 메소드가 객체에 따라 고유한 방법으로 응답함.



---

## 2.요구사항 확인

* 요구사항 유형
  * 기능 요구사항(시스템의 필수적 기능), 비기능 요구사항(기능 외 품질이나 제약사항)
  * 사용자 요구사항(사용자 관점), 시스템 요구사항(개발자 관점)
* 요구사항 개발 프로세스: 요구사항 도출 -> 분석 -> 명세 -> 확인



* 하향식 비용 산정 기법: 과거 유사 경험 바탕으로 개발자들의 회의를 통해 비용을 산정.
  * 전문가 감정 기법: 조직의 두 명 이상의 전문가에게 비용 산정을 의뢰.
  * 델파이 기법: 많은 전문가의 의견을 종합하여 비용 산정.
* 상향식 비용 산정 기법: 프로젝트 세부 작업 단위별로 비용 산정 후 집계하여 전체 비용을 산정하는 방법.
  * LOC 기법
    * LOC: 총 라인 수
    * 노력(=인월) =  투입 인원 * 개발 기간 = LOC / 1인당 월평균 생산 라인 수
    * 개발 비용 = 노력 * 단위 비용(1인당 월평균 인건비)
    * 개발 기간 = 노력 / 투입 인원
    * 생산성 = LOC / 노력
    * 예시) 총 라인 수가 40,000라인, 개발자 10명, 개발자 평균 생산성이 월 400라인일 때 개발에 소요되는 기간은? 10개월



* **UML**: 개발자와 고객, 개발자 상호간에 의사소통이 원활하게 이루어지도록 표준화한 객체지향 모델링 언어
  * **유스케이스 다이어그램**: 개발될 시스템과 관련된 사용자, 외부 시스템들이 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현.
    * 시스템 범위, 주액터(사람), 부액터(시스템), 유스케이스, 관계
    * 관계: 포함(<<indlude\>>), 확장(<<extends\>>), 일반화
  * **활동 다이어그램**: 자료 흐름도와 유사하게 사용자 관점에서 처리 흐름에 따라 표현.
    * 액션, 액티비티, 노드, **스윔레인**
  * **클래스 다이어그램**: 클래스 간 관계 표현한 정적 모델링.
    * 클래스(클래스명+-#~, 속성, 오퍼레이션), 제약조건, 관계
  * **시퀀스 다이어그램**: 시스템, 객체들이 **메세지를 주고받으며** 시간 흐름에 따라 상호작용하는 과정을 표현.
    * 액터, 객체, **라이프라인**, **활성 상자**, 메세지
  * **커뮤니케이션 다이어그램**: 객체 간 메세지 + 객체 간 관계 포함.
    * 액터, 객체, 메세지, 링크
  * **상태 다이어그램**: 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호작용에 따라 상태가 어떻게 변하는지 표현.
    * 상태, 시작 상태(●), 종료 상태(◉), 상태전환, 이벤트, 프레임



---

## 3.데이터 입출력 구현

* **데이터 모델**: 현실세계의 정보들을 컴퓨터에 표현하기 위해 단순화, 추상화하여 표현한 개념적 모형.
  * 구성요소: 개체, 속성, 관계
  * 표시할 요소: 구조, 연산, 제약조건

* **이상**: 테이블에서 일부 속성의 종속으로 인해 데이터 중복이 발생하고, 이로 인해 테이블 조작 시 문제가 발생하는 현상.
  * 삽입 이상(삽입을 못함), 삭제 이상(연쇄 삭제), 갱신 이상(일부만 갱신->정보 불일치성 발생)
* **함수적 종속**: 어떤 테이블에서 속성 A의 값에 대해 속성 B의 값이 오직 하나만 연관되어 있을 때 B는 A에 함수적 종속이라 하고 A→B로 표기함. A→B 관계에서 속성 A를 **결정자**, 속성 B를 **종속자**라고 함.
  * 예) 학번, 이름, 학년, 학과 속성으로 이루어진 테이블에서, 학번만 알면 이름, 학년, 학과를 알 수 있으므로 이름, 학년, 학과는 학번에 함수적 종속이다.
  * 완전 함수적 종속: 기본키인 속성 집합에 대해, 한 속성이 기본키에 대해서만 함수적 종속인 경우.
  * 부분 함수적 종속: 한 속성이 기본키만이 아니라 기본키의 부분집합에 대해서도 함수적 종속인 경우.

* **정규화**: 데이터 중복을 제거하기 위해 테이블을 **무손실 분해**하는 과정.
  * 제1정규형(1NF): 모든 **도**메인이 원자값. (테이블의 한 칸은 하나의 정보만 담음)
  * 제2정규형(2NF): **부**분적 함수 종속 제거. 즉 모든 속성이 완전 함수적 종속이 되도록 테이블을 쪼갬.
  * 제3정규형(3NF): **이**행적 함수 종속 제거. 한 테이블에서 A→B, B→C일 때, A→B인 테이블과 B→C인 테이블로 쪼갬.
    * 이행적 함수 종속: A→B, B→C일때 A→C. 
  * BCNF: **결**정자이면서 후보키가 아닌 것 제거. A→B인데 A가 그 테이블에서 후보키가 아닐 때(즉 중복값이 있을 때) 테이블을 쪼갬.
  * 제4정규형(4NF): **다**치 종속을 제거.
    * 다치 종속: B가 복합 속성(A, C)에 대해 A에만 종속이고 C에는 무관할 때. A↠B로 표기.
  * 제5정규형(5NF): **조**인 종속성 이용.

* **반정규화**: 시스템 성능향상, 개발 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하여 의도적으로 정규화 원칙을 위배하는 것.
  * 테이블 통합, 테이블 분할, 중복 테이블 추가, 중복 속성 추가



* **인덱스**: 데이터 레코드에 빠르게 접근하기 위해 <키값, 포인터> 쌍으로 구성되는 데이터 구조.
  * 트리 기반 인덱스(블록이 트리 구조), 비트맵 인텍스(인덱스 키가 비트값 0/1), 도메인 인덱스(개발자가 직접 만들어 사용)
* **뷰**: 사용자에게 접근이 허용된 자료만 제한적으로 보여주기 위해 기본 테이블로부터 유도된 가상의 테이블.
* **클러스터**: 액세스 효율 향상을 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법. 조회속도는 향상시키지만 입력, 수정, 삭제 성능은 저하.

* **파티션**: 대용량의 테이블이나 인덱스를 작은 논리적 단위로 나누는 것.
  * 범위 분할(열 기준), 해시 분할(해시함수 적용결과 기준), 조합 분할(범위->해시)



---

## 4.통합 구현

* 연계 메커니즘 구성
  * 송신 시스템(테이블이나 파일 형식으로 데이터 생성)
  * 수신 시스템(전송받은 데이터를 변환 후 운영DB에 반영)
  * 중계 시스템(데이터와 송수신시스템 현황 모니터링)
  * 연계 데이터 생성 및 추출 → 코드 매핑 및 데이터 변환 → 인터페이스 테이블 또는 파일 생성 → 연계 서버 또는 송신 어댑터
     -(전송)→ 연계 서버 또는 수신 어댑터 → 인터페이스 테이블 또는 파일 생성 → 코드 매핑 및 데이터 변환 → 운영 DB에 연계 데이터 반영
* 직접 연계 방식: 중간 매개체 없이 송수신 시스템이 직접 연결.
  * DB Link: DB에서 제공하는 DB Link 객체를 이용하는 방식.
  * API: 데이터를 송신 시스템의 DB에서 읽어와 제공함. API와 Open API.
  * DB Connection: 수신 시스템의 WAS에서 송신 시스템의 DB로 연결해주는 방식.
  * JDBC: Java에서 DB에 접근하여 데이터를 삽입, 삭제, 수정, 조회할 수 있도록 Java와 DB를 연결해주는 방식.
* 간접 연계 방식: 중간 매개체를 두어 연계.
  * **연계 솔루션**: EAI 서버와 송·수신 시스템에 설치되는 클라이언트를 이용하는 방식.
  * ESB: 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 방식.
  * Socket: 서버는 통신을 위한 소켓을 생성하여 포트를 할당하고 클라이언트의 통신 요청 시 클라이언트와 연결하여 통신하는 네트워크 기술.
  * 웹 서비스: 웹 서비스에서 WSDL과 UDDI, SOAP 프로토콜을 이용하여 연계하는 방식.
* 연계 모듈 구현 환경
  * EAI: 각종 애플리케이션 및 플랫폼 간의 상호 연동이 가능하게 해주는 솔루션.
    * **Point-to-Point**: 애플리케이션 간에 1:1로 연결하는 방식. 변경 및 재사용 어려움.
    * **Hub&Spoke**: 단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식. 확장 유지보수 용이.
    * **Message Bus**(ESB방식): 애플리케이션 사이에 미들웨어를 두어 처리하는 방식. 확장성 뛰어나며 대용량 처리 가능.
    * **Hybrid**: Hub&Spoke와 Message Bus의 혼합. 그룹 내에서는 Hub&Spoke, 그룹 간에는 Message Bus 방식 사용. 데이터 병목현상 최소화.
  * **ESB**: 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션. ESB는 애플리케이션 통합 측면에서 EAI와 유사하지만 보다 **서비스 중심**의 통합을 지향함.

  * 웹 서비스: 네트워크 정보를 표준화된 서비스 형태로 만들어 공유하는 기술. 서비스 지향 아키텍처(SOA) 개념을 실현하는 대표적인 기술.
    * **SOAP**: HTTP, HTTPS, SMTP 등을 활용하여 **XML 기반의 메세지를 네트워크 상에서 교환**하는 프로토콜.
    * **UDDI**: **WSDL을 등록**하여 서비스와 서비스 제공자를 검색하고 접근하는 데 이용.
    * **WSDL**: 웹 서비스명, 서비스 제공 위치, 프로토콜 등 **웹 서비스에 대한 상세 정보**를 XML 형식으로 구현.
* **XML**: 웹브라우저 간 HTML 문법이 호환되지 않는 문제와 SGML의 복잡함을 해결하기 위하여 개발된 다목적 마크업 언어.
* **SOAP**: 컴퓨터 네트워크 상에서 HTTP, HTTPS, SMTP 등을 이용해 XML을 교환하기 위한 통신규약.
* **WSDL**: 웹 서비스 관련 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어.
  * XML로 작성되며 UDDI의 기초가 됨.
* **JSON**: 속성-값 쌍으로 이루어진 데이터 객체를 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷. 비동기 처리 AJAX에서 XML을 대체하여 사용됨.



---

## 5.서버 프로그램 구현

#### 개발 환경 구축

* 하드웨어 환경: 클라이언트와 서버로 구성
  * **웹 서버**: 클라이언트로부터 직접 요청을 받아 처리하는 서버.
    * HTTP/HTTPS 지원: 브라우저의 요청에 응답할 때 사용되는 프로토콜.
    * 통신기록: 처리한 요청을 로그로 저장.
    * 정적 파일 관리: HTML, CSS, 이미지 등을 저장하고 관리.
    * 대역폭 제한: 네트워크 트래픽 포화 방지를 위해 응답 속도 제한.
    * 가상 호스팅: 한 서버로 여러 도메인 네임을 연결.
    * 인증: 사용자가 합법적인 사용자인지 확인하는 기능.
  * **웹 애플리케이션 서버(WAS)**: **사용자에게 동적 서비스를 제공하기 위해** 웹 서버의 요청을 받아 데이터 가공 작업을 수행하거나, 웹 서버-DB서버 또는 웹 서버-파일 서버 사이에서 **인터페이스 역할**을 수행하는 미들웨어.
  * **데이터베이스 서버**: DB와 DBMS를 운영하는 서버.
  * **파일 서버**: DB에 저장하기에는 비효율적이거나 서비스 제공을 목적으로 유지하는 파일들을 저장하는 서버.
* 소프트웨어 환경: 시스템 소프트웨어와 개발 소프트웨어로 구성.
  * 시스템 소프트웨어: 운영체제, 서버 프로그램, DBMS
  * 개발 소프트웨어: 요구사항 관리도구(JIRA,Trello..), 설계/모델링 도구(DB Designer, PlantUML..), 구현 도구(Eclipse, Visual Studio..), 빌드 도구(Ant, Gradle, Maven..), 테스트 도구(JUnit, SpringTest..), 형상 관리 도구(GIT, Subvision..)



* **결합도**: 아래로 갈수록 결합도↑ (데스제외공내)
  * **데이터 결합도**: 모듈 간의 인터페이스가 자료 요소로만 구성.
  * **스탬프 결합도**: 모듈 간의 인터페이스로 배열이나 레코드 등을 전달.
  * **제어 결합도**: 한 모듈이 다른 모듈의 논리적 흐름을 제어함. (권리 전도 현상 발생)
  * **외부 결합도**: 한 모듈에서 선언한 변수를 다른 모듈에서 참조.
  * **공통 결합도**: 공통 데이터 영역을 여러 모듈이 사용. 
  * **내용 결합도**: 한 모듈이 다른 모듈의 내부 기능 및 자료를 직접 참조하거나 수정.
* **응집도**: 아래로 갈수록 응집도↓ (기순교절시논우)
  * **기능적 응집도**: 모듈 내 모든 요소가 단일 문제와 연관되어 수행.
  * **순차적 응집도**: 모듈 내 하나의 활동으로 나온 출력을 그 다음 활동의 입력으로 사용.
  * **교환적 응집도**: 동일한 입출력을 사용해 서로 다른 기능을 수행하는 요소들이 모였을 경우.
  * **절차적 응집도**: 모듈이 여러 관련 기능을 가질 때 모듈 안의 요소들이 그 기능을 순차적으로 수행.
  * **시간적 응집도**: 특정 시간에 처리되는 기능들을 모아 모듈을 형성.
  * **논리적 응집도**: 유사한 성격의 요소들을 모아 모듈을 형성.
  * **우연적 응집도**: 모듈 내 요소들이 서로 관련이 없음.



* 웹 응용 시스템: 웹 서버와 WAS로 구성. 웹 응용 프로그램이 DBMS에 접근하기 위한 인터페이스 역할.

* DBMS 접속 기술
  * **JDBC**: Java언어로 다양한 종류의 데이터베이스에 접속하고 SQL문을 수행할 때 사용되는 표준 API.
  * **ODBC**: 데이터베이스에 접근하기 위한 **표준 개방형** API. 개발 언어에 관계없이 사용 가능.
  * **MyBatis**: **JDBC 코드를 단순화**하여 사용할 수 있는 SQL Mapping 기반 오픈소스 접속 프레임워크.

* 동적 SQL(Dynamic SQL): 다양한 조건에 따라 SQL 구문을 동적으로 변경하여 처리할 수 있는 방식.



* 서버 개발 프레임워크: 대부분 모델-뷰-컨트롤러(MVC) 패턴을 기반으로 개발.
  * Spring: Java 기반. 전자정부 표준 프레임워크의 기반 기술.
  * Node.js: JavaScript 기반. 비동기 입출력 처리와 이벤트 위주의 높은 처리성능.
  * Django: Python 기반. 컴포넌트 재사용과 플러그인화 강화로 신속한 개발 가능.
  * Codeigniter: PHP 기반. 인터페이스가 간편하여 서버 자원을 적게 먹음.
  * Ruby on Rails: Ruby 기반. 테스트를 위한 웹 서버 지원. DB작업을 단순화, 자동화시켜 코드 길이 짧음.
* 프레임워크의 특성: 모듈화, 재사용성, 확장성, 제어의 역흐름



#### 서버 개발 과정

* DTO/VO(Data Transfer Object/Value Object) 구현: **데이터 교환에 사용할 객체**를 만드는 과정.
* SQL 구현: **데이터를 삽입, 변경, 삭제하는 SQL문**을 생성하는 과정.
* DAO(Data Access Object) 구현: **DB에 접근하고 SQL을 이용해 데이터를 실제로 조작하는 코드**를 구현하는 과정.
* Service 구현: **사용자의 요청에 응답하기 위한 로직**을 구현하는 과정.
* Controller 구현: **사용자 요청에 적절한 서비스를 호출 + 결과를 사용자에게 반환하는 코드**를 구현하는 과정.
* (사용자 요청) -> Controller -> Service -> DAO -> SQL -> (DB 에서 데이터를 받아 다시 역행하여 응답)



* 배치 프로그램: 여러 작업들을 미리 정해진 순서에 따라 일괄적으로 처리하는 것.
  * 정기 배치(정기적), 이벤트성 배치(특정 조건), On-Demand 배치(사용자 요청)
  * 필수요소: 대용량 데이터, 자동화, 견고성(중단 없이), 안정성/신뢰성(오류추적), 성능
* 배치 스케줄러(Batch Scheduler): 일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구.
  * Spring Batch: Spring Source사와 Accenture사가 2007년 공동 개발한 오픈소스 프레임워크. 로그 관리, 추적, 트랜잭션 관리, 작업 처리 등.
  * Quarts: 스프링 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈소스 라이브러리.
  * Cron: 리눅스 스케줄러 도구. ( 분 시 일 월 요일{일0~토6} 명령어 )
    * 30 1 * * * /root/bat.sh : 매월 매일 1시 30분에 bat.sh를 실행.
    * 30 */3 * * * /root/bat.sh: 매일 00:30부터 3시간마다 실행.
    * \* 18-23 20 * * /root/bat.sh: 매월 20일 18시~23시 매분마다 실행.
    * 30 23 25 4,9,11 * /root/bat.sh: 4월, 9월, 11월 25일 23시 30분에 실행.



####  디자인 패턴

* **생성 패턴(Creational)**
  * **Abstract Factory**: 인터페이스를 통해 서로 연관된 객체들의 그룹으로 생성.
  * **Builder**: 작은 인스턴스들을 조합하여 객체 생성. 객체 생성과 표현 과정을 분리 -> 동일한 객체 생성에도 다른 결과 가능.
  * **Factory Method**: 상위 클래스에서 인터페이스만 정의 -> 서브 클래스에서 객체 생성.
  * **Prototype**: 원본 객체를 복제. 비용이 큰 경우 주로 이용.
  * **Singleton**: 클래스 내 인스턴스를 단 하나만 생성하여 여러 곳에서 사용.
* **구조 패턴(Structural)**
  * **Adapter**: 호환성이 없는 인터페이스를 다른 클래스가 사용가능하도록 변환.
  * **Bridge**: 기능과 구현을 별도 클래스로 분리 -> 서로가 독립적으로 확장 가능.
  * **Composite**: 객체들을 트리 구조의 복합 클래스로 구성. 복합 in 복합도 가능.
  * **Decorator**: 임의의 객체에 부가적인 기능을 가진 다른 객체를 덧붙여서 확장.
  * **Facade**: 상위에 인터페이스를 구성해 서브클래스를 간편하게 사용.
  * **Flyweight**: 인스턴스를 매번 생성하지 말고 한번 생성한걸 가능한 한 공유.
  * **Proxy**: 접근이 어려운 객체와 다른 객체간 인터페이스 역할.
* **행위 패턴(Behavioral)**
  * **Chain of Responsibility**: 요청을 처리하는 객체가 여럿 존재하여 한 객체가 처리를 못하면 다음 객체로 넘어감.
  * **Command**: 요청을 객체화하여 저장하거나 로그에 남김.
  * **Interpreter**: 다른 언어 사용.
  * **Iterator**: 접근이 잦은 객체에 동일한 인터페이스를 사용.
  * **Mediator**: 객체 간 복잡한 상호작용을 객체화. 결합도를 감소시킴.
  * **Memento**: 특정 시점의 객체 내부를 객체화하여 되돌리기 가능. Ctrl+Z등을 구현할때 사용.
  * **Observer**: 한 객체의 상태가 변화하면 상속된 다른 객체에게 전달. 분산된 시스템 간에 이벤트 생성하고 수신할 때 사용.
  * **State**: 객체의 상태에 따라 동일한 동작을 다르게 처리.
  * **Strategy**: 동일 계열 알고리즘을 개별적으로 캡슐화하여 클라이언트는 원하는 알고리즘 선택.
  * **Template Method**: 상위 클래스에서 골격을 정의하고 하위 클래스에서 내부 구현.
  * **Visitor**:각 클래스에서 처리 기능을 분리하여 별도의 클래스로 구성. 처리 기능은 각 클래스를 방문하여 수행.



---

## 6.화면 설계

* **사용자 인터페이스(UI)**: 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 소프트웨어.
  * **CLI**: 명령과 출력이 텍스트 형식으로 이뤄지는 인터페이스.
  * **GUI**: 아이콘이나 메뉴를 마우스로 선택하여 작업하는 인터페이스.
  * **NUI**: 사용자의 말이나 행동으로 기기를 조작하는 인터페이스.
  * 인터페이스 기본 원칙: **직관성**(누구나 쉽게 이해, 사용), **유효성**(사용자 목적을 정확히 수행), **학습성**(누구나 쉽게 익힘), **유연성**(사용자 요구사항을 최대한 수용하고 실수 최소화)
* UI 설계 지침: 사용자 중심, 일관성, 단순성, 결과 예측 가능, 표준화, 접근성, 명확성, 오류 발생 해결
* UI 설계 도구
  * **와이어프레임**: 기획 초기에 페이지의 개략적인 레이아웃, UI 요소 등을 설계하는 단계.
  * **목업**: 와이어프레임보다 좀더 실제 화면처럼 만든 정적인 모형.
  * **스토리보드**: 와이어프레임에 콘텐츠 설명, 페이지간 이동 흐름 등을 추가한 문서.
  * **프로토타입**: 와이어프레임이나 스토리보드에 상호작용을 적용. 실제 구현된 것처럼 테스트가 가능한 동적 모형.
    * 페이퍼 프로토타입: 스케치, 글, 그림 등을 이용해 손으로 작성.
    * 디지털 프로토타입: 파워포인트, 아크로뱃 등 프로그램을 사용.
  * **유스케이스**: 사용자 측면의 요구사항. 사용자가 목표를 달성하기 위해 수행할 내용을 기술.
    * 빠른 요구사항 파악 → 프로젝트 초기에 기능적 요구를 결정.



* 웹의 3요소: 웹 표준, 웹 접근성, 웹 호환성

* UI 스타일 가이드 작성 순서: 구동 환경 정의 → 레이아웃 정의 → 네비게이션 정의 → 기능 정의 → 구성요소 정의



* 프로토타입: 요구사항을 기반으로 실제 동작하는 것처럼 만든 동적 모형. 테스트가 가능함.
  * 페이퍼 프로토타입: 비용이 저렴. 회의 중 생성 가능. 테스트 부적합. 여러 사람에게 공유하기 어려움.
  * 디지털 프로토타입: 최종제품과 비슷하게 테스트 가능. 재사용 용이. 프로그램 사용법을 알아야 함.



* UI 흐름 설계 순서: 기능 작성 → 입력 요소 확인 → 유스케이스 설계 → 기능 및 양식 확인



---

## 7.애플리케이션 테스트 관리

* 애플리케이션 테스트: 애플리케이션에 잠재된 결함을 찾아내는 일련의 과정.
  * 개발된 소프트웨어가 고객의 **요구사항을 만족**하는지 **확인(Validation)**하고 소프트웨어가 **기능을 정확히 수행**하는지 **검증(Verification)**한다.
* 애플리케이션 테스트 기본 원리
  * **결함 집중(Defect Clusturing)**: 결함은 대부분 특정 모듈에 집중됨 **(파레토 법칙, Pareto Principle)**
  * **오류-부재의 궤변(Absence of Errors Fallacy)**: 결함을 모두 제거해도 사용자 요구사항을 만족하지 못함
  * 테스팅은 **정황(Context)** 의존: 소프트웨어 특징, 테스트 환경, 테스터 역량 등에 따라 결과 다름
  * 살충제 패러독스(Pesticide Paradox): 동일한 테스트케이스로 동일한 테스트를 반복하면 더이상 결함이 발견되지 않는 현상.
  * 테스트의 점진적 확대: 작은 부분에서 큰 부분으로
  * 테스트의 별도 팀 수행: 개발과 관계없는 팀에서 진행



#### 애플리케이션 테스트의 분류

* 프로그램 실행 여부에 따른 분류
  * 정적 테스트: 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트. 워크스루, 인스펙션, 코드 검사..
  * 동적 테스트: 프로그램을 실행하여 오류를 찾는 테스트. 블랙박스 테스트, 화이트박스 테스트..
* 테스트 기반에 따른 분류
  * **명세 기반 테스트**: 사용자 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 확인하는 테스트. (블랙박스 테스트)
  * **구조 기반 테스트**: 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트. (화이트박스 테스트)
  * 경험 기반 테스트: 유사 소프트웨어나 기술 등에 대한 테스터 경험을 기반으로 수행하는 테스트. 에러 추정, 체크리스트, 탐색적 테스팅..

* 목적에 따른 테스트
  * **회복(Recovery) 테스트**: 시스템에 여러 결함을 줘 실패하도록 한 후 올바르게 복구되는지 테스트.
  * 안전(Security) 테스트: 시스템 보호 도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지 테스트.
  * 강도(Stress) 테스트: 과부하 시에도 정상 작동하는지 테스트.
  * 성능(Perfomance) 테스트: 응답시간, 처리량 등을 테스트.
  * 구조(Structure) 테스트: 논리적 경로, 소스 복잡도 등을 테스트.
  * **회귀(Regression) 테스트**: 수정된 코드에 새로운 결함이 없는지 확인하는 테스트.
  * **병행(Parallel) 테스트**: 변경된 것과 기존 것에 동일한 데이터를 입력해 결과를 비교하는 테스트.

* **화이트박스 테스트**: **원시 코드를 오픈**시킨 상태에서 **모든 논리적인 경로를 테스트**하여 테스트 케이스를 설계하는 방식. 원시 코드의 모든 문장을 한 번 이상 수행.

  * 기초 경로 검사: 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법.
  * 제어 구조 검사
    * 조건 검사(모듈 내의 논리적 조건을 테스트)
    * 루프 검사(반복구조에 초점을 두고 테스트)
    * 데이터 흐름 검사(변수의 정의와 사용에 초점을 두고 테스트)

  * 검증 기준
    * 문장 검증 기준: 모든 구문이 수행되도록 설계
    * 분기 검증 기준: 모든 조건문이 수행되도록 설계
    * 조건 검증 기준: 모든 조건문이 True인 경우와 False인 경우가 수행되도록 설계
    * 분기/조건 기준: 모든 조건문과 각 조건문에 포함된 개별 조건식 결과가 True/False인 경우가 수행되도록 설계

* **블랙박스 테스트**: 소프트웨어의 각 기능이 완전히 작동되는 것을 입증하는 테스트. 명세 기반.

  * **동치 분할 검사**: 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 기법.
  * **경계값 분석**: 입력 조건의 경계값을 테스트 케이스로 선정하여 검사.
  * **원인-효과 그래프 검사**: 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석하여 효용성이 높은 테스트 케이스를 선정하는 기법.
  * **오류 예측 검사**: 과거의 경험이나 확인자의 감각으로 테스트하는 기법.
  * **비교 검사**: 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법.

* 개발 단계에 따른 애플리케이션 테스트: 단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트



#### 통합 테스트

* 비점진적 통합 방식: 모든 모듈이 결합된 프로그램 전체를 테스트. 빅뱅 통합 테스트.
* 점진적 통합 방식: 모듈을 단계적으로 통합하며 테스트. 하향식, 상향식, 혼합식 통합 테스트.
  * 하향식 통합 테스트: 프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하며 테스트.
    * 깊이 우선 통합법과 넓이 우선 통합법이 있음. 
    * 주요 제어 모듈은 작성된 프로그램을, 종속 모듈들은 **스텁(Stub)**으로 대체함. 통합 방식에 따라 스텁이 하나씩 실제 모듈로 교체됨. 

  * 상향식 통합 테스트: 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하며 테스트. 
    * 하위 모듈들을 **클러스터(Cluster)**로 결합하고 상위 모듈은 데이터 입출력 확인을 위한 더미 모듈인 **드라이버(Driver)**를 작성.
    * 통합된 클러스터 단위로 테스트하고 테스트가 완료되면 클러스터는 프로그램 상위 구조로 이동, 드라이버는 실제 모듈로 대체됨.

  * 혼합식 통합 테스트: 하위 수준에서 상향식, 상위 수준에서 하향식 테스트. 샌드위치식 통합 테스트.

  * 각 통합 간에는 회귀 테스트를 시행함.



#### 결함 관리

* 결함(Fault): 오류 발생, 작동 실패 등 소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 것.
* 결함 관리 프로세스
  * 결함 관리 계획 → 결함 기록 → 결함 검토 → 결함 수정 → 결함 재확인 → 결함 상태 추적 및 모니터링 활동 → 최종 결함 분석 및 보고서 작성
* 결함 관리 측정 지표
  * **결함 분포**: 모듈 또는 컴포넌트의 특정 속성에 해당하는 결함 수 측정
  * **결함 추세**: 테스트 진행 시간에 따른 결함 수의 추이 분석
  * **결함 에이징**: 특정 결함 상태로 지속되는 시간 측정
* 결함 추적 순서: 등록(Open) → 검토(Reviewed) → 할당(Assigned) → 수정(Resolved) → 종료(Closed) → 해제(Clarified)



* 소스 코드 최적화 유형
  * 클래스 분할 배치: 한 클래스는 하나의 역할만 수행하도록 응집도 높이고 크기를 작게 작성
  * Loosly Coupled(느슨한 결합): 인터페이스 클래스를 이용해 추상화된 자료구조와 메소드를 구현하여 클래스 간 의존성을 최소화
  * **팩토리 메소드 패턴**: 상위 클래스에서 객체 생성하는 인터페이스를 정의하고 하위 클래스에서 실제 객체를 만드는 방식. (생성과 사용을 분리)
  * 코딩 형식 준수: 줄바꿈, 개념적 유사성 높은 종속 함수 사용, 호출하는 함수는 선배치, 호출되는 함수는 후배치, 지역 변수는 각 함수의 맨 처음에 사용 등
  * 좋은 이름 사용(명명규칙), 적절한 주석문 사용



---

## 8.SQL 응용

#### DDL

```mysql
-- 테이블 정의
CREATE TABLE 학생(
	이름 VARCHAR(15) NOT NULL,
    학번 CHAR(8) PRIMARY KEY,
    전공 CHAR(5),
    성별 CHAR(1) CONSTRAINT 성별_chk CHECK(성별 IN('남','녀'))
    생년월일 DATE,
    FOREIGN KEY(전공) REFERENCE 학과(학과코드)
    	ON DELETE SET NULL
    	ON UPDATE CASCADE, -- NO ACTION, SET NULL, SET DEFAULT, CASCADE
    CONSTRAINT 생년월일제약 CHECK(생년월일>='1980-01-01')
    );

-- 테이블 정의 변경
ALTER TABLE 학생 ADD 학년 VARCHAR(3);
ALTER TABLE 학생 ALTER 학번 VARCHAR(10) NOT NULL;
ALTER TABLE 학생 DROP COLUMN 학년; -- CASCADE 사용 가능

-- 정의 제거
DROP TABLE 테이블명 [CASCADE|RESTRICTED];
```



#### DCL

```mysql
-- 권한을 부여/취소
GRANT DBA TO John; -- DBA(DB관리자), RESOURCE(DB 및 테이블 생성), CONNECT(단순 정보 검색)
REVOKE DBA TO John;
GRANT SELECT ON 고객리스트 TO John WITH GRANT OPTION; -- John에게 고객리스트를 검색할 권한을 주고 그 권한을 타인에게 부여할 수 있는 권한도 줌
REVOKE GRANT OPTION FOR SELECT ON 고객리스트 FROM John; -- John에게서 고객리스트를 검색하는 권한을 부여하는 권한을 취소함
```

* **COMMIT**: 트랜잭션이 성공적으로 끝났을 때 변경된 모든 내용을 DB에 반영하는 명령. (COMMIT;)
* **ROLLBACK**: COMMIT되지 않은 내용을 취소. (ROLLBACK TO 저장점;)
* **SAVEPOINT**: 트랜잭션 내에 ROLLBACK할 저장점을 지정. (SAVEPOINT 저장점;)



#### DML

```mysql
-- 삽입문
INSERT INTO 사원리스트(이름, 부서) VALUES("홍길동","인터넷");
INSERT INTO 편집부원(이름,생일,주소,기본급)
	SELECT 이름,생일,주소,기본급 FROM 사원리스트 WHERE 부서="편집";

-- 삭제문
DELETE FROM 사원리스트 WHERE 이름='임꺽정';

-- 갱신문
UPDATE 사원리스트 SET 부서='기획', 기본급 = 기본급+5 WHERE 이름='유관순';

-- 성이 김씨인 튜플을 검색
SELECT * FROM 사원 WHERE 이름 LIKE "김%";

-- 생일이 69년 1월 1일~73년 12월 31일인 튜플 검색
SELECT * FROM 사원 WHERE 생일 BETWEEN #01/01/69# AND #12/31/73#;

-- 주소가 NULL인 튜플 검색
SELECT * FROM 사원 WHERE 주소 IS NULL;

-- 취미가 영화감상인 사원의 이름과 주소 검색
SELECT 이름,주소 FROM 사원 
	WHERE 이름 IN (SELECT 이름 FROM 여가활동 WHERE 취미="영화감상"); -- 이름 = (SELECT~)도 가능

-- id가 10인 스태프가 담당하는 가게 이름을 검색 (단 중복 레코드는 한번만 표시)
SELECT DISTINCT name FROM Shop WHERE id=(SELECT shopid FROM Staff WHERE id=10);


-- 부서별 상여금 평균을 "평균" 속성으로 표시
SELECT 부서, AVG(상여금) AS 평균 FROM 상여금 GROUP BY 부서;

-- 상여금이 100 이상인 사원이 2명 이상인 부서의 사원 수
SELECT 부서, COUNT(*) AS 사원수 FROM 상여금 WHERE 상여금>=100 
	GROUP BY 부서 HAVING COUNT(*) >= 2;
```

* ROLLUP(속성1,속성2..): 인수로 주어진 속성을 대상으로 그룹별 소계를 구함.
* CUBE(속성1, 속성2..): 주어진 속성을 대상으로 모든 조합의 그룹별 소계를 구함.



#### 절차형 SQL

* 프로시저: 특정 기능을 수행하는 일종의 트랜잭션 언어. 호출을 통해 미리 저장해둔 SQL 작업을 수행함.

  * EXECUTE or EXEC or CALL 명령어를 이용해서 사용.

  ```mysql
  CREATE OR REPLACE PROCEDURE score_count(sc IN INT)
  IS
  	a INT;
  BEGIN
  	SELECT COUNT(*) INTO a FROM score WHERE cond>=sc;
  	INSERT INTO total(mem_count) VALUES(a);
  	EXCEPTION
  		WHEN PROGRAM_ERROR THEN ROLLBACK;
  	COMMIT;
  END;
  ```

* 트리거: 데이터 삽입, 갱신, 삭제 등 이벤트 발생 시 관련 작업이 자동으로 수행되는 절차형 SQL.

  ```mysql
  CREATE OR REPLACE TRIGGER 사원_trigger AFTER UPDATE ON 사원
  FOR EACH ROW
  BEGIN
  	IF (태도/성과)/2 >= 50 THEN
  		DBMS_OUTPUT.PUT_LINE('우수');
  	ELSE
  		DBMS_OUTPUT.PUT_LINE('미달');
  	END IF;
  END;
  ```

* 사용자 정의 함수: SQL을 이용하여 일련의 작업을 연속적으로 처리하며 처리결과를 단일 값으로 반환하는 절차형 SQL.

  ```mysql
  CREATE FUNCTION Find_Name(idx IN INT)
  RETURN VARCHAR2
  IS
  	a VARCHAR2(10);
  BEGIN
  	SELECT s_name INTO a FROM product WHERE s_id = idx;
  	RETURN a;
  END;
  ```



---

## 9.소프트웨어 개발 보안 구축

* 서비스 거부 공격(DoS)의 유형
  * **Ping of Death**: 패킷 크기를 인터넷 프로토콜 허용 범위(65536Byte) 이상으로 전송하여 네트워크를 마비시킴.
  * **스머핑**: IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 집중적으로 보내는 공격.
  * **SYN Flooding**: TCP의 3-way-handshake 과정을 중단시켜 서버를 메모리 공간을 확보한 대기상태로 만드는 공격.
  * **TearDrop**: Fragment Offset 값을 변경시켜 수신측에서 패킷을 재조립할 때 오류로 인한 과부하 발생.
  * **DDoS(분산 서비스 거부) 공격**: 네트워크에 취약한 호스트들에 분산 서비스 공격용 툴(데몬)을 설치해 에이전트로 만든 후 DDoS 공격에 이용.
  * Land Attack: 패킷 전송시 송신 IP주소와 수신 IP주소를 모두 공격대상의 IP주소로 하여 전송.
* 네트워크 침해 공격 관련 용어
  * **스미싱**: SMS를 이용해 개인정보를 빼내는 수법. 소액결제, apk파일을 설치하도록 유도.
  * **스피어 피싱**: 사회공학의 한 기법. 특정 대상 선정 후 일반적인 이메일로 위장한 메일을 지속적으로 발송하여 메일 본문 링크나 첨부 파일을 클릭하도록 유도.
  * **APT**: 조직적으로 특정 기업이나 조직 네트워크에 침투하여 보안을 무력화시키고 정보를 외부로 빼돌리는 공격. 내부자에게 악성코드가 포함된 이메일을 오랜 기간 꾸준히 발송, 스턱스텟과 같이 악성코드가 담긴 USB 등으로 전파, 악성코드에 감염된 P2P 사이트 등.
  * **무작위 대입 공격**: 암호를 찾아내기 위해 가능한 모든 값을 대입하여 공격.
  * **큐싱**: QR코드를 통해 악성 앱 다운 유도.
  * **SQL 삽입 공격**: 전문 스캐너 프로그램 등으로 무차별적으로 공격하다 취약한 사이트가 발견되면 DB 조작 공격.
  * **크로스 사이트 스크립팅**: 사용자 스크립트 악용. 사용자가 특정 게시물이나 이메일 링크를 클릭하면 악성 스크립트가 실행됨.
* 정보 보안 침해 관련 용어
  * 좀비PC: C&C 서버의 제어를 받아 주로 DDoS 공격에 이용.
  * C&C서버: 해커가 원격지에서 좀비PC에 명령을 내리고 제어하기 위해 사용하는 서버.
  * 봇넷: 악성 프로그램에 감염된 다수의 컴퓨터들이 네트워크로 연결된 형태.
  * 웜: 네트워크를 통해 연속적으로 자신을 복제하여 시스템 부하를 높이는 바이러스.
  * 제로데이 공격: 보안 취약점이 발견되었을 때 신속하게 공격.
  * 키로거(Key Logger) 공격: 컴퓨터 사용자의 키보드 움직임을 탐지.
  * 랜섬웨어: 사용자의 문서나 파일을 암호화.
  * 백도어: 시스템 설계자가 프로그래머의 액세스 편의를 위해 만들어둔 비밀통로.
  * 트로이 목마: 정상적인 프로그램으로 위장한 악성 프로그램. 자가복제 능력은 없음.



* 소프트웨어 보안 관련 기관
  * 행정안전부: 소프트웨어 개발 보안 정책을 총괄.
  * 한국인터넷진흥원: 소프트웨어 개발 보안 정책 및 가이드를 개발.

  

* **Secure SDLC**: SDLC 각 단계별로 보안 강화를 위한 프로세스를 포함하는 것.

  * 보안 요소
    * **기밀성**: 인가된 자만 접근, 노출되더라도 데이터를 읽을 수 없게 함
    * **무결성**: 인가된 자만 수정
    * **가용성**: 인가된 자는 언제나 사용 가능
    * **인증**: 시스템 자원을 사용하려는 사용자가 합법적인 사용자인지 확인
    * **부인 방지**: 데이터를 송수신한 자가 부인할 수 없도록 송수신한 증거 제공
  * 요구사항 분석 → 설계 → 구현 → 테스트 → 유지보수



* 잘못된 세션에 의한 정보 노출: 멀티 스레드 환경에서 멤버 변수에 정보를 저장할 때 발생.

* TOCTOU 경쟁조건: 검사 시점과 사용 시점을 고려하지 않은 경우 발생하는 보안 약점.

* 스택 트레이스: 오류가 발생한 위치를 추적하기 위해 소프트웨어가 실행 중에 호출한 메소드 리스트를 기록한 것.
* 에러처리(예외처리): 소프트웨어 실행 중 발생할 수 있는 오류들을 사전에 정의하여 문제를 예방하기 위한 점검 항목들.



#### 암호 알고리즘

* 암호화 방식
  * 단방향: HASH
  * 양방향
    * 개인키: Block 방식, Stream 방식
    * 공개키
* 개인키 암호화 기법: 동일한 키로 데이터를 암호화하고 복호화함.
  * 블록 암호화: 한번에 하나의 데이터 블록을 암호화함. DES, SEED, AES, ARIA
  * 스트림 암호화: 평문과 동일한 길이의 스트림을 생성해 비트 단위로 암호화. LFSR, RC4
* 공개키 암호화 기법: 암호화에 공개키, 복호화에 비밀키를 사용. 공개키는 데이터베이스 사용자에게 공개하고 비밀키는 관리자가 관리. 비대칭 암호화라고도 함. 대표적으로 RSA 기법이 있음.
* 양방향 알고리즘 종류
  * SEED: 1999년 한국인터넷진흥원(KISA). 블록 크기 128비트, 키 길이에 따라 128, 256으로 분류.
  * ARIA: 2004년 국가정보원과 산학연협회. 블록 크기 128비트, 키 길이에 따라 128, 192, 256으로 분류.
  * DES: 1975년 미국 NBS. 블록 크기 64비트, 키 길이 56비트.
  * AES: 2001년 미국 표준기술 연구소(NIST). 블록 크기 128비트, 키 길이에 따라 128, 192, 256으로 분류.
  * RSA: 1978년 MIT. 공개키. 큰 숫자는 소인수분해가 어려운 점에 착안.
* 해시(hash): 임의의 길이의 입력값을 고정 길이의 값으로 변환. 데이터 암호화, 무결성 검증, 정보보호 등.
  * SHA 시리즈: 1993년 미국 NSA가 제작하고 미국 국립표준기술연구소에서 표준으로 채택. 가장 널리 사용.
  * MD5: MD4를 개선.
  * SNEFRU: 1990년 R.C.Merkle에 의해 제안된 128, 254비트 암호화 알고리즘



---

## 10.응용 SW 기초 기술 활용

* 운영체제 성능평가기준
  * 처리능력: 일정 시간 내 처리량
  * 반환시간: 작업 의뢰~처리 완료까지 걸린 시간
  * 사용 가능도: 시스템을 사용할 필요가 있을 때 바로 사용 가능한 정도
  * 신뢰도: 시스템이 주어진 문제를 정확하게 해결하는 정도
* 계층구조: 하드웨어 관리-CPU 관리-기억장치 관리-프로세스 관리-주변장치 관리-파일시스템-사용자 프로세스
* 주요 자원 관리
  * 프로세스 관리: 스케줄링, 동기화, 생성과 제거, 시작과 정지, 메세지 전달
  * 기억장치 관리: 메모리 할당 및 회수
  * 주변장치 관리: 입출력장치 스케줄링 및 전반적인 관리
  * 파일 관리: 파일 생성과 삭제, 변경, 유지



* Windows 특징
  * GUI
  * **선점형 멀티태스킹**: 동시에 여러 프로그램을 실행하는 멀티태스킹 → 프로그램 실행 중 문제가 생기면 강제 종료하고 모든 자원을 반환.
  * **PnP(Plug and Play)**: 하드웨어 설치 시 시스템 환경 자동 구성 (하드웨어, 소프트웨어 모두 PnP를 지원해야 함)
  * **OLE(Object Linking Embedding)**: 응용프로그램간에 문자나 그림 등의 자료 공유. OLE로 연결된 이미지를 원본에서 수정하거나 편집하면 해당 문서에 반영.
  * **Single-User**: 한 대를 한 사람만 독점.

* UNIX 특징
  * C언어로 작성 → 이식성, 호환성 높음
  * 트리 구조의 파일 시스템
  * 구성
    * 하드웨어 - 커널 - 쉘 - 유틸리티 - 사용자
    * **커널**: UNIX의 핵심. 프로그램-하드웨어 간 인터페이스 역할. 프로세스 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 반환..
    * **쉘**: 사용자의 명령어를 인식해 프로그램을 호출, 명령을 수행. 시스템과 사용자 간의 인터페이스 역할. 



* 기억장치 관리 전략: 반입(요구,예상), 배치(최초, 최적, 최악 접합), 교체(FIFO, OPT, LRU..)



* 프로세스 상태 전이: 제출 -> 접수 -> 준비 -> 실행 (or 대기) -> 종료
  * Dispatch: 준비 → 실행 (프로세서 할당됨)
  * Wake Up: 대기 → 준비 (입출력이 끝남)
  * Spooling: 입출력 데이터를 나중에 한꺼번에 처리하기 위해 디스크에 저장하는 과정.



* 데이터베이스 정의
  * 통합된 데이터: 중복 최소화된 데이터의 모임
  * 저장된 데이터: 컴퓨터가 접근가능한 저장매체에 저장된 데이터
  * 운영 데이터: 조직의 고유 업무를 수행하는 데 필요한 데이터
  * 공용 데이터: 여러 응용 시스템들이 공동으로 소유하고 유지하는 데이터
* DBMS 필수 기능: 정의, 조작, 제어 기능



* 릴레이션: 데이터를 2차원 표의 형태로 표현한 것. 릴레이션 스키마와 릴레이션 인스턴스로 구성.
  * **튜플**: 릴레이션의 각 행(레코드). 튜플의 수를 기수(카디널리티)라고 함
  * **속성**: 릴레이션의 각 컬럼(필드). 속성의 수를 차수(Degree)라고 함
  * **도메인**: 한 속성이 취할 수 있는 같은 타입의 값들의 집합. 예) 성별 = (남, 여)
  * **릴레이션 스키마**: 릴레이션의 이름, 각 속성의 이름과 타입, 속성값의 도메인 등 릴레이션의 틀을 정의
  * **릴레이션 인스턴스**: 어느 한 시점에서 릴레이션에 존재하는 튜플의 집합

* 정보 공학 표기법
  * 박스 위에 개체명, 박스 내 첫칸에 기본키를 씀
  * |(필수), ○(선택적), <(다중)으로 관계 표현



* **후보키**: 튜플을 유일하게 식별할 수 있는 키, 기본키로 사용 가능한 속성들. **유일성**, **최소성**을 가져야 함.
  * **기본키**: 후보키 중에서 선정된 주 키. NULL값을 가질 수 없음.
  * **대체키**: 기본키가 아닌 후보키.
* **슈퍼키**: 속성들의 집합으로 이뤄진 키. 유일성은 만족하지만 최소성은 만족못함. (유일성을 만족하는 모든 단일키, 복합키의 집합)
* **외래키**: 다른 릴레이션의 기본키를 참조하는 속성 또는 속성의 집합. 

* **복합키**: 둘 이상의 속성으로 이뤄진 후보키.



**무결성(Integrity)**: DB의 데이터와 현실의 실제 값이 일치하는 정확성.

* **개체 무결성**: 기본키 속성은 Null값이나 중복값을 가질 수 없음. (NULL 무결성 + 고유 무결성)
* **도메인 무결성**: 주어진 속성의 값이 정의된 도메인에 속한 값이어야 함.
* **참조 무결성**: 외래키의 값은 Null 아니면 참조 릴레이션의 기본키 값이어야 함. 즉 참조할 수 없는 외래키 값을 가질 수 없음.
* 사용자 정의 무결성: 속성 값들이 사용자가 정의한 제약조건을 만족해야 함.
* NULL 무결성: 특정 속성 값이 NULL이 될 수 없음.
* 고유 무결성: 릴레이션의 특정 속성에 대해 각 튜플의 값이 중복되어선 안 됨.
* 키 무결성: 한 릴레이션에 적어도 하나의 키가 존재해야 함.
* 관계 무결성: 어느 한 튜플의 삽입 가능 여부 또는 릴레이션들의 튜플들 간의 관계에 대한 적절성 여부를 지정.



* 네트워크: 두 대 이상의 컴퓨터를 케이블 등으로 연결하여 자원을 공유하는 것.
  * 근거리 통신망(LAN): 비교적 가까운 거리에 있는 컴퓨터, 프린터, 저장장치 등의 자원을 연결하여 구성.
  * 광대역 통신망(WAN): 국가-국가, 대륙-대륙 등 멀리 떨어진 사이트끼리 연결하여 구성. LAN끼리 연결.

* IPv6 주소체계
  * 유니캐스트: 단일 송신자와 단일 수신자 간의 통신 (1:1)
  * 멀티캐스트: 단일 송신자와 다중 수신자 간의 통신 (1:N)
  * 애니캐스트: 단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신 (1:1)



* **OSI 참조모델**: 1~3계층은 하위계층, 4~7계층은 상위계층임.
  * **물리 → 데이터링크 → 네트워크 → 전송 → 세션 → 표현 → 응용** (물데네전세표응)
* OSI 참조모델에서의 데이터 단위
  * 프로토콜 데이터 단위(**PDU**): 동일 계층 간 교환되는 정보의 단위.
    * 물리: 비트
    * 데이터링크: 프레임
    * 네트워크: 패킷
    * 전송: 세그먼트
    * 세션, 표현, 응용: 메세지
  * 서비스 데이터 단위(SDU): 서비스 접근점(SAP)을 통해 상/하위 계층끼리 주고받는 정보의 단위.

* **물리 계층**: 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의. 리피터, 허브.
* **데이터 링크 계층**: 두 개의 인접한 개방 시스템들 간의 정보 전송. 흐름 제어, 프레임 동기화, 오류 제어, 순서 제어 기능. 랜카드, 브리지, 스위치.
* **네트워크 계층**: 개방 시스템 간의 네트워크 연결과 데이터 교환. 경로 설정(라우팅), 트래픽 제어, 패킷 정보 전송. 라우터.

* **전송 계층**: 하위계층과 상위계층의 인터페이스 담당. **종단 시스템(End-to-End)** 간의 전송 연결 설정. **오류 제어, 흐름 제어**. TCP, UDP 등. 게이트웨이.
* **세션 계층**: 대화 구성 및 동기 제어, 데이터 교환 관리 기능. 대화 동기를 위해 전송하는 정보의 일정한 부분에 체크포인트(동기점)를 두어 정보의 수신 상태를 체크.
* **표현 계층**: 응용 계층과 세션 계층 간 데이터 변환 기능을 함. 서로 다른 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요.
* **응용 계층**: 응용 프로그램이 OSI 환경에 접근할 수 있도록 서비스를 제공.



* 허브: 가까운 거리의 컴퓨터들을 연결. 리피터 기능도 포함.
  * 더미 허브: 네트워크에 흐르는 모든 데이터를 단순히 연결만 함. LAN이 보유한 대역폭을 컴퓨터 수만큼 나누어 제공. (100MB 대역폭을 5개 컴퓨터에 나누면 대당 20MB)
  * 스위칭 허브: 네트워크에 흐르는 데이터의 유무 및 흐름을 제어하여 각각의 노드가 최대 대역폭을 사용하게 함.
* 리피터: 약해진 신호를 원래 형태로 재생하여 전송.
* 브리지: LAN과 LAN을 연결하거나 LAN 안에서의 세그먼트를 연결. MAC 브리지라고도 함. 트래픽 병목 현상 줄임. 브리지를 이용한 서브넷 구성 시 전송 가능한 회선 수는 브리지가 n개일 때 n(n-1)/2개임.
* 스위치: LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치. 하드웨어 기반으로 전송 속도가 빠름. 
  * L2 스위치: 일반적으로 스위치라 하면 이것. MAC 주소를 기반으로 프레임 전송.
  * L3 스위치: L2 스위치에 라우터 기능 추가. IP 주소 기반으로 패킷 전송.
  * L4 스위치: 로드밸런서가 달린 L3 스위치. TCP/UDP 기반으로 사용자 요구를 서버 부하가 적은 곳에 배분하는 로드밸런싱 기능을 함.
  * L7 스위치: IP주소, TCP/UDP 포트 정보, 패킷 내용까지 참조해 세밀하게 로드밸런싱함.
* 라우터: LAN과 LAN 연결 기능에 최적 경로 선정 기능 추가. LAN과 WAN의 연결도 수행.
* 게이트웨이(Gateway): 전 계층의 프로토콜 구조가 다른 네트워크의 연결을 수행. 세션, 표현, 응용 계층 간을 연결하여 데이터형식변환, 주소변환, 프로토콜 변환 등을 수행. LAN에서 다른 네트워크와 데이터를 주고받는 출입구 역할.



* 프로토콜: 서로 다른 기기들 간의 데이터 교환을 수행하기 위한 표준화된 통신규약. 구문, 의미, 시간.

* TCP/IP: 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜.

  * TCP: 신뢰성 있는 양방향 연결형 서비스 제공. 패킷 다중화, 순서 제어, 오류 제어, 흐름 제어 제공. 스트림 위주의 전달(패킷).
  * IP: 데이터그램 기반의 비연결형 서비스 제공. 패킷 분해/조립, 주소 지정, 경로 선택 기능 제공. 헤더 길이는 20~60바이트.

* TCP/IP 계층 구조

  |       OSI        |        TCP/IP        |                             기능                             |
  | :--------------: | :------------------: | :----------------------------------------------------------: |
  | 응용, 표현, 세션 |      응용 계층       | 응용 프로그램간 데이터 송수신 제공<br>TELNET, FTP, SMTP, SNMP, DNS, HTTP 등 |
  |       전송       |      전송 계층       |       호스트 간의 신뢰성 있는 통신 제공<br>TCP, UDP 등       |
  |     네트워크     |     인터넷 계층      | 데이터 전송을 위한 주소 지정, 경로 설정을 제공<br>IP, ICMP, IGMP, ARP, RARP 등 |
  | 데이터링크, 물리 | 네트워크 액세스 계층 | 실제 데이터(프레임)를 송수신하는 역할<br>Ethernet, IEEE 802, HDLC, X.25, RS-232C, ARQ 등 |

* **응용 계층**의 주요 프로토콜

  * **FTP**: 파일을 주고받는 원격 파일 전송 프로토콜.
  * **SMTP**: 전자 우편 교환 서비스.
  * **TELNET**: 멀리 떨어진 컴퓨터에 접속하여 자신의 컴퓨터처럼 이용 가능하게 하는 서비스.
  * **SNMP**: TCP/IP의 네트워크 관리 프로토콜. 라우터나 허브 등 네트워크 기기의 정보를 관리 시스템에 보내는 데 사용.
  * **DNS**: 도메인 네임을 IP로 매핑하는 시스템.
  * **HTTP**: WWW에서 HTML 문서를 송수신하기 위한 프로토콜

* **전송 계층**의 주요 프로토콜

  * **TCP**: 양방향 연결(Full Duplex Connection)형 서비스 제공. 가상 회선 연결(Virtual Circuit Connection) 서비스 제공. 순서 제어, 오류 제어, 흐름 제어 기능. 투명성 있는 통신 보장.
  * **UDP**: 비연결형 서비스 제공. TCP에 비해 단순한 헤더 구조로 오버헤드가 적음. 빠른 속도 필요, 동시에 여러 사용자에게 데이터 전달, 정기적으로 반복해서 보낼 경우에 사용. 실시간 전송에 유리. 신뢰성보다 속도 중요시되는 네트워크에 사용.
  * RTCP: RTP 패킷의 전송 품질을 제어하는 프로토콜. 세션의 각 참여자에게 주기적으로 제어 정보 전송. 하위 프로토콜은 데이터 패킷과 제어 패킷의 다중화를 제공. 데이터 전송 모니터링. 최소한의 제어와 인증 기능만 제공. RTCP 패킷은 항상 **32비트**의 경계로 끝남.

* **인터넷 계층**의 주요 프로토콜

  * **IP**: 전송할 데이터에 주소를 지정하고 경로를 설정하는 기능. 비연결형인 데이터그램 방식으로 신뢰성이 보장되지 않음.
  * **ICMP**: IP와 조합하여 통신 중 발생하는 오류 처리와 전송 경로 변경 등을 위한 제어 메세지 관리.
  * **IGMP**: 멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지.
  * **ARP**: IP주소 -> MAC주소
  * **RARP**: MAC주소 -> IP주소



#### 데이터 교환 방식/라우팅

* 회선 교환 방식: 통신을 원하는 두 지점을 교환기를 이용하여 물리적으로 접속시키는 방법.
  * 공간 분할 교환 방식(SDS): 기계식 접점과 전자 교환기의 전자식 접점 등을 이용
  * 시분할 교환 방식(TDS): 다수의 디지털 신호를 시분할적으로 동작시켜 다중화
* 패킷 교환 방식: 메세지를 일정한 길이의 패킷으로 잘라서 전송.
  * 가상 회선 방식: 단말간에 논리적인 가상 통신 회선을 미리 설정하여 설정된 경로를 따라 패킷을 운반.
  * 데이터그램 방식: 경로를 설정하지 않고 인접한 노드들의 트래픽 상황을 감안하여 각 패킷들을 독립적으로 운반.

* 라우팅: 송수신측 간의 전송 경로 중 최적 패킷 교환 경로를 결정하는 기능.

  * 라우팅 프로토콜
    * **RIP**: 가장 널리 사용됨. 소규모 동종 네트워크 내에서 효율적.
    * **IGRP**: RIP 단점 보완. 네트워크 상태를 고려해 라우팅. 중규모에 적합.
    * **OSPF**: 대규모 네트워크에 사용. 라우팅 정보에 변화가 생기면 변화된 정보만 네트워크 내 모든 라우터에 알림.
    * BGP: 자율 시스템(AS) 간의 라우팅 프로토콜. EGP의 단점 보완.
  * 라우팅 알고리즘
    * 거리 벡터 알고리즘: 인접 라우터 간의 거리와 방향에 대한 정보를 이용해 최적 경로 탐색. RIP, IGRP.
    * 링크 상태 알고리즘: 모든 경로를 파악해 미리 대체 경로를 마련해두는 알고리즘. OSPF.




---

## 11.제품 소프트웨어 패키징

* **소프트웨어 패키징**: 모듈별로 생성한 실행 파일들을 묶어 배포용 설치파일을 만듦. 사용자 중심.
* 패키징 순서
  1. 기능 식별: 코드의 기능 확인
  2. 모듈화: 기능 단위로 코드를 분류
  3. 빌드: 모듈별로 실행파일 만듦
  4. 사용자 환경 분석
  5. 패키징 및 적용 테스트: 빌드된 실행파일들을 배포용 파일형식으로 패키징.
  6. 패키징 변경 개선
  7. 배포



* **릴리즈 노트**: 개발 과정에서 정리된 릴리즈 정보를 사용자와 공유하기 위한 문서.
* 작성 순서
  1. **모듈 식별**: 모듈별 빌드 후 작성할 내용 확인

  2. **릴리즈 정보 확인**: 노트 이름, 소프트웨어 이름, 버전, 날짜, 노트 날자, 노트 버전

  3. **릴리즈 노트 개요 작성**

  4. **영향도 체크**: 버그, 이슈, 기능 변화가 다른 소프트웨어 사용에 미칠 수 있는 영향을 기술

  5. **정식 릴리즈 노트 작성**: Header, 개요, 영향도 체크 항목을 포함해 작성

  6. **추가 개선 항목 식별**: 추가버전 릴리즈노트 작성이 필요할 경우 추가 릴리즈 노트 작성



* **DRM**: 저작권자가 배포한 디지털 콘텐츠가 저작자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술.
  * 클리어링 하우스: 저작권에 대한 사용 권한, 라이선스 발급, 사용량에 따른 결제 등 관리
  * 콘텐츠 제공자: 저작권자
    * 패키저: 콘텐츠를 메타 데이터와 함께 묶어 암호화하는 프로그램
  * 콘텐츠 분배자: 암호화된 컨텐츠를 유통
  * 콘텐츠 소비자: 콘텐츠를 사용하는 주체
    * DRM 컨트롤러: 배포된 콘텐츠의 이용권한을 통제하는 프로그램
    * 보안 컨테이너: 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안장치

  * 기술 요소: 암호화, 키 관리, 암호화 파일 생성, 식별 기술, 정책 관리, 크랙 방지, 인증



* 소프트웨어 설치 매뉴얼 작성: 기능 식별 -> UI 분류 -> 설치 파일/백업 파일 확인 -> Uninstall 절차 확인 -> 이상 Case 확인 -> 최종 매뉴얼 적용
* 소프트웨어 사용자 매뉴얼 작성: 기능 식별 -> 사용자 화면 분류 -> 사용자 환경 파일 설정 -> 초기화 절차 확인 -> 이상 Case 확인 -> 최종 매뉴얼 적용
  * Profile: 소프트웨어 구동에 필요한 환경을 점검파는 파일. 사용자가 경로를 바꾸지 않도록 안내해야 함.



* **형상관리**: 개발 과정에서 소프트웨어의 변경사항을 관리하기 위한 일련의 행위
* 버전 등록 과정
  * Import -> Check-Out -> Commit -> Update(다른 개발자가 동기화) -> Diff(이전 개발자의 수정기록을 확인)

* 버전 관리 도구

  * 공유 폴더 방식: 버전 관리 자료가 로컬 컴퓨터의 공유 폴더에 저장
  * 클라이언트/서버 방식: 버전 관리 자료가 중앙 시스템(서버)에 저장
  * 분산 저장소 방식: 버전 관리 자료를 원격 저장소, 개발자 PC 로컬 저장소에 함께 저장

* **Subversion(서브버전, SVN)**: CVS를 개선한 것으로 클라이언트/서버 방식. 아파트 소프트웨어 재단에서 발표. 서버는 주로 UNIX 사용.

  * import(최초 등록) -> checkout -> 작업 -> add -> update -> commit

* **Git**: 리누스 토발즈가 2005년 리눅스 커널 개발에 사용할 관리 도구로 개발, 주니오 하마노에 의해 유지보수. 분산 저장소 방식. 로컬 저장소에서 버전 관리가 수행. 파일의 변화를 스냅샷으로 저장함.

  * init: 로컬 저장소 생성.
  * remote add: 원격 저장소에 연결.
  * add: 작업 내역을 스테이징 영역에 추가. add --all로 모든 파일을 추가할 수 있음.
  * commit: 작업 내역을 로컬 저장소에 저장.
  * push: 로컬 저장소 변경 내역을 원격 저장소에 반영.
  * branch: 새로운 브랜치 생성.  --d로 삭제 가능.
  * checkout: HEAD 포인터(현재 작업중인 브랜치)를 지정한 브랜치로 이동.
  * merge: 지정한 브랜치의 변경 내역을 HEAD 포인터가 가리키는 브랜치에 반영하여 병합.
  * fetch: 원격 저장소의 변경 이력을 로컬 저장소에 반영.
  * clone: 원격 저장소의 전체 내용을 로컬 저장소에 반영.
  * fork: 지정한 원격 저장소의 내용을 자신의 원격 저장소로 복제.

  ```
  // 계정 설정
  $ git --global user.name "Kim"
  $ git --global user.email "Kim@google.com"
  
  // 지역 저장소 생성
  $ git init
  
  // 작업 내역을 스테이징 영역에 추가
  $ git add --all
  
  // 작업 내역을 지역 저장소에 저장
  $ git commit -m "첫번째 커밋"
  
  // 병합 기능 사용하기
  $ git branch new_br
  $ git checkout new_br
  $ git add text.py
  $ git commit -m "두번째 커밋"
  $ git checkout master
  $ git merge new_br
  $ git branch --d new_br
  
  // 지역 저장소 변경 내역을 원격 저장소에 반영
  $ git remote add remote_repo http://github.com/Kim/repository.git
  
  // 지역 저장소 변경 내역을 원격 저장소에 저장
  % git push remote_repo master
  ```



* **빌드**: 소스 코드 파일을 컴파일하고 여러 개의 모듈을 묶어 실행파일을 만드는 과정.
* **Jenkins**: JAVA 기반 오픈 소스. Web GUI 제공.  분산 빌드 및 테스트 가능. SVN, Git 등 대부분 형상 관리 도구와 연동 가능.
* **Gradle**: Groovy 기반 오픈 소스. 안드로이드 앱 개발 환경에 사용.
  * 플러그인을 설정하면 JAVA, C/C++, Python도 빌드 가능.
  * Groovy로 만든 DSL을 스크립트 언어로 사용.
  * 실행할 처리 명령들을 모아 태스크로 만든 후 **태스크 단위**로 실행.
  * 이전 태스크 재사용 혹은 다른 시스템의 태스크를 공유하는 **빌드 캐시 기능** 지원.