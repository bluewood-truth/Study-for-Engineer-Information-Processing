### 141. 운영체제의 개념 - A

* 운영체제(Operation System): 컴퓨터 시스템의 자원들을 효율적으로 관리하며 사용자를 위한 환경을 제공하는 프로그램의 모임.  사용자와 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어.
  * 목적: **처리능력**(시간당 처리량), **반환시간**(의뢰~완료), **사용 가능도**(자원을 즉시 사용가능), **신뢰도**(문제를 정확히 해결)의 향상
  * 기능
    * 프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원 관리, 자원 스케줄링 기능 제공
    * 각종 하드웨어와 네트워크 관리
    * 데이터 관리, 데이터 및 자원 공유, 자원 보호
    * 시스템 오류 검사 및 복구, 입출력에 대한 보조 기능, 가상 계상기(1대를 여러대처럼) 기능 제공
  * 주요 자원 관리
    * 프로세스 관리: 스케줄링, 동기화, 생성과 제거, 시작과 정지, 메세지 전달
    * 기억장치 관리: 메모리 할당 및 회수
    * 주변장치 관리: 입출력장치 스케줄링 및 전반적인 관리
    * 파일 관리: 파일 생성과 삭제, 변경, 유지
  * 종류
    * Windows: MS 개발. GUI. 개인용.
    * UNIX: AT&T Bell, MIT, Genearl Electric이 공동개발. CLI. 서버용.
    * LINUX: UNIX와 호환가능한 커널. 프리웨어. CLI. 서버용.
    * MacOS: 애플의 UNIX기반. GUI. 개인용.
    * MS-DOS: Windows 이전. CLI. 단일 작업 처리 시스템. 개인용.

<br>

### 142. Windows - C

* 특징
  * GUI
  * **멀티태스킹(멀티프로그래밍)**: 여러 프로그램을 동시 실행
  * **PnP(Plug and Play)**: 하드웨어 설치 시 시스템 환경 자동 구성 (하드웨어, 소프트웨어 모두 PnP를 지원해야 함)
  * **OLE(Object Linking Embedding)**: 응용프로그램간에 문자나 그림 등의 자료 공유. OLE로 연결된 이미지를 원본에서 수정하거나 편집하면 해당 문서에 반영.
  * 255자의 긴 파일명: \/:*?"<>| 제외 한글은 127자까지.
  * **Single-User**: 한 대를 한 사람만 독점.

<br>

### 143. UNIX / LINUX / MacOS - A

* **UNIX**
  * 시분할 시스템을 위해 설계된 대화식 운영체제. 소스가 공개된 Open System.
  * C언어로 작성 -> 이식성, 호환성 높음
  * 다중사용자, 멀티태스킹 지원 (포그라운드, 백그라운드)
  * 네트워크 관리용으로 적합
  * 트리 구조의 파일 시스템
  * 구성
    * 하드웨어 - 커널 - 쉘 - 유틸리티 - 사용자
    * **커널**: UNIX의 핵심. 컴퓨터 부팅 시 주기억장치에 적재, 상주함. 하드웨어 보호, 프로그램-하드웨어 간 인터페이스 역할. 프로세스 관리, 기억장치 관리, 파일 관리, 입출력 관리, 프로세스간 통신, 데이터 전송 및 반환..
    * **쉘**: 사용자의 명령어를 인식해 프로그램을 호출, 명령을 수행. 시스템과 사용자 간의 인터페이스 역할. 보조기억장치에서 교체 처리가 가능. 파이프라인 지원, 출력과 입력의 방향 변경 가능. 공용 Shell이나 사용자가 만든 Shell을 사용할 수 있음.
    * 유틸리티: 일반 사용자가 작성한 응용 프로그램 처리에 사용. DOS로 치면 외부 명령어. 에디터, 컴파일러, 인터프리터, 디버거 등..
  * 프로세스 간 통신(IPC)
    * 시그널: 간단한 메세지, 초기 UNIX
    * 파이프: 한 프로세스의 출력이 다른 프로세스의 입력으로, 단방향 통신
    * 소켓: 프로세스 간 대화, 쌍방향 통신
* LINUX
  * 프로그램 소스 코드가 무료로 공개, UNIX와 완벽 호환, 대부분 특징이 비슷
* MacOS
  * 아이맥, 맥북 등 애플사 제품에만 사용. 드라이버 실치 및 인스톨, 언인스톨 과정이 단순함.

<br>

### 144. 기억장치 관리의 개요 - A

* 레지스터(CPU) ↔ 캐시 기억장치(SRAM) ↔ 주기억장치(DRAM) ↔ 보조기억장치(HD, SSD)

  * ->로 갈수록 접근속도, 비트당 가격 감소. 기억용량 증가.

  * 주기억장치는 각각 자신의 주소를 갖는 워드 또는 바이트로 구성. 주소로 접근 가능.
  * 레지스터, 캐시, 주기억장치 프로그램과 데이터는 CPU가 직접 액세스 가능.
  * 보조기억장치 데이터는 주기억장치에 적재 후 CPU가 액세스 가능.

* 기억장치 관리 전략

  * 반입(Fetch): 보조기억장치의 데이터를 언제 주기억장치에 적재할 것인지를 결정
    * 요구 반입(Demand): 실행중인 프로그램이 참조 요구
    * 예상 반입(Anticipatory): 실행중인 프로그램에 의해 참조될 데이터 예상
  * 배치(Placement): 새로 반입되는 데이터를 주기억장치의 어디에 위치시킬까 결정
    * 최초 적합: 빈 영역 중에서 첫번째 영역에 배치
    * 최적 적합: 단편화를 가장 적게 남기는 영역에 배치
    * 최악 적합: 단편화를 가장 많이 남기는 영역에 배치 
  * 교체(Replacement): 주기억장치의 모든 영역이 사용중일 때 새 데이터를 어디에 교체할까 결정
    * FIFO, OPT, LRU, LFU, NUR, SCR 등

<br>

### 145. 주기억장치 할당 방법 - C

* 주기억장치 할당 (할당=Loading)
  * **연속 할당 기법**: 주기억장치에 연속적으로 할당. **단일 분할 할당**과 **다중 분할 할당**이 있음.
  * 분산 할당 기법(가상기억장치): 프로그램을 특정 조각으로 나누어 주기억장치 내에 분산하여 할당. 페이징 기법과 세그먼테이션 기법이 있음.
* **단일 분할 할당**: 주기억장치를 운영체제 영역과 사용자 영역으로 나눔 -> 한 순간에 오직 한 명의 사용자만이 사용자영역을 사용. 가장 단순, 초기 운영체제에 사용. 운영체제와 사용자를 구분하는 경계 레지스터 사용.
  * 오버레이 기법: 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법. 하나의 프로그램을 여러 조각으로 분할하여 적재. 프로그래머는 시스템 구조를 알아야 함.
  * 스와핑 기법: 하나의 프로그램 전체를 주기억장치에 할당하고 필요에 따라 교체함. 교체를 여러번 수행할 수 있음. 가상기억장치의 페이징 기법으로 발전함.
* **다중 분할 할당**
  * **고정 분할 할당 기법(MFT)=정적 할당 기법**: 운영체제가 주기억장치의 사용자 영역을 여러 개의 고정된 크기로 분할 -> 프로그램을 각 영역에 할당
    * 프로그램 전체가 주기억장치에 적재됨. 내부 단편화(분할된 영역이 작아서 안쓰임), 외부 단편화(분할된 영역이 커서 빈 공간이 남음)로 주기억장치의 낭비가 많음.
  * **가변 분할 할당 기법(MVT) = 동적 할당 기법**: 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 분할하는 기법.
    * 다중 프로그래밍 정도를 높일 수 있음. 실행될 프로세스 크기에 대한 제약이 적음. 단편화를 대부분 해결 가능하나 영역 간에 단편화 발생할 수 있음.

<br>

### 146. 가상기억장치 구현 기법 / 페이지 교체 알고리즘 - A

* 가상기억장치: 보조기억장치의 일부를 주기억장치처럼 사용하는 기법.
  * 프로그램을 여러 개의 블록 단위로 나누어 가상기억장치에 보관해놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당해 관리.
  * 가상기억장치에 저장된 프로그램을 실행하려면 주소 변환(Mapping) 작업이 필요.
  * 주소 매핑 시 가상주소가 반드시 연속적인 실기억주소로 변환될 필요는 없음. (인위적 연속성)
  * 블록의 종류에 따라 페이징 기법과 세그먼테이션 기법으로 나뉨.
* **페이징 기법**: 프로그램과 주기억장치 영역을 동일한 크기로 나눈 후 나눠진 프로그램(페이지)을 주기억장치 영역(페이지 프레임)에 적재시켜서 실행. 내부 단편화 발생. 페이지 맵 테이블이 필요하고 이로 인해 비용 증가, 처리속도 감소.
* **세그먼테이션 기법**: 가상기억장치의 프로그램을 다양한 크기의 논리적 단위(세그먼트)로 나누어 주기억장치에 적재시켜 실행. 기억장치의 사용자 관점을 보존하는 기법. 기억공간 절약. 외부 단편화 발생.

* 페이지 교체 알고리즘: 페이지 부재(Page Fault: CPU가 액세스한 가상 페이지가 주기억장치에 없는 경우)가 발생했을 때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 교체할 것인지 결정하는 기법.
  * OPT(OPTimal replacement): 최적 교체. 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체.
  * FIFO: 선입선출. 가장 오래된 페이지를 교체.
  * LRU(Least Recently Used): 최근 가장 오랫동안 사용하지 않은 페이지를 교체. 각 페이지마다 Counter나 스택을 두어 가장 오래 사용되지 않은 페이지를 찾음.
  * LFU(Least Frequently Used): 사용 빈도가 가장 적은 페이지를 교체.
  * NUR(Not Used Recently): LRU와 비슷. 페이지마다 두 개의 하드웨어 비트(참조 비트, 변형 비트)가 필요. 참조 비트가 작을수록, 참조 비트가 같다면 변형 비트가 작을수록 먼저 교체됨.
  * SCR(Second Change Replacement): 2차 기회 교체. 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지. FIFO 단점 보완.

<br>

### 147. 가상기억장치 기타 관리 사항 - A

* 페이지 크기
  * 작을 경우: 불필요한 내용이 적재될 확률이 적어 효율적인 워킹 셋을 유지. Locality에 더 일치할 수 있기 때문에 기억장치 효율 높아짐. 맵 테이블이 커지고 매핑속도가 늦어짐. 디스크 접근횟수가 많아져 입출력 시간이 늘어남.
  * 클 경우: 맵 테이블이 작아지고 매핑 속도 빨라짐. 디스크 접근 횟수가 줄어들어 입출력 효율성 증가. 페이지 단편화 증가, 한 개의 페이지를 주기억장치로 이동하는 시간 증가. 불필요한 내용까지 적재될 수 있음.
* Locality: 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론. 워킹 셋 이론의 기반. 가상기억장치 관리의 이론적 근거. 캐리 메모리 시스템의 이론적 근거.
  * 시간 구역성(Temporal Locality): 프로세스가 실행되면서 하나의 페이지를 일정 시간동안 집중적으로 액세스하는 현상. 루프, 스택, 서브루틴, 카운팅(1씩 증감), 집계에 사용되는 변수(기억장소).
  * 공간 구역성(Spatial Locality): 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상. 배열 순회, 순차적 코드의 실행, 프로그래머들이 관련된 변수를 서로 근처에 선언함 등
* 워킹 셋(Working Set): 프로세스가 일정 시간동안 자주 참조하는 페이지들의 집합. 프로그램의 Locality를 이용. 페이지 부재 및 페이지 교체가 줄어들어 프로세스의 기억장치 사용이 안정됨. 시간에 따라 변경됨.

* 페이지 부재의 빈도 방식: 페이지 부재율에 따라 주기억장치에 있는 페이지 프레임 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식. 초기에 임의의 페이지 프레임을 할당하고, 부재율이 상한선을 넘으면 좀더 많은 페이지 프레임을 할당하고, 하한선을 넘으면 페이지 프레임을 회수하는 방식을 사용.
* 프리페이징: 처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 모든 페이지를 한꺼번에 페이지 프레임에 적재하는 기법. 
* 스래싱: 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상. 다중 프로그래밍이나 가상기억장치 사용 시 자주 페이지 부재가 발생하면 일어남. 다중 프로그래밍의 정도가 높아질수록 CPU 이용률은 높아지지만 어느 시점부터 스래싱이 발생해 CPU 이용률은 급감함.
  * 스래싱 방지 방법: 다중 프로그래밍 정도를 적정 수준으로 유지. 페이지 부재 빈도를 조절하여 사용. 워킹 셋을 유지. 부족한 자원을 증설하고 일부 프로세스 중단. CPU 성능을 분석해 임계치를 예상하여 운영.

<br>

### 148. 프로세스의 개요 - A

* 프로세스: 프로세서(처리기, CPU)에 의해 처리되는 실행중인 프로그램. 작업(Job), 태스크(Task)라고도 함.
  * PCB를 가진 프로그램. 실기억장치에 저장된 프로그램. 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위. 프로시저가 활동중인 것. 비동기적 행위를 일으키는 주체. 지정된 결과를 얻기 위한 일련의 계통적 동작. 목적 또는 결과에 따라 발생되는 사건들의 과정. 운영체제가 관리하는 실행 단위.
* PCB(Process Control Block): 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳. TCB 또는 JCB라고도 함. 
  * 프로세스의 현재 상태, 포인터, 프로세스 고유 식별자, 스케줄링 및 프로세스의 우선순위, CPU 레지스터 정보, 주기억장치 관리 정보, 입출력 상태 정보, 계정 정보 등
* 프로세스 상태 전이
  * 제출(Submit): 작업을 처리하기 위해 시스템에 제출.
  * 접수(Hold): 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장.
  * 준비(Ready): 프로세스는 준비상태 큐에서 실행을 준비. 접수->준비의 전환은 Job 스케줄러에 의해 수행.
  * 실행(Run): 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행. 프로세서 할당 시간이 종료되면(Timer Run Out) 다시 준비상태로 전이됨. 입출력 처리가 필요할 경우 대기 상태로 전이. 준비->실행 전이는 CPU(프로세서) 스케줄러에 의해 수행.
  * 대기(Wait), 보류, 블록(Block): 입출력 처리가 필요하여 실행중인 프로세스가 중단된 상태.
  * 종료(Terminated, Exit): 프로세스의 실행이 끝나고 할당이 해제된 상태.
* 프로세스 상태 전이 관련 용어
  * Dispatch: 준비 상태의 프로세스 중 하나가 프로세서를 할당받아 실행상태로 전이되는 과정.
  * Wake Up: 입출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이되는 과정.
  * Spooling: 입출력 데이터를 직접 입출력장치에 보내지 않고 나중에 한꺼번에 처리하기 위해 디스크에 저장하는 과정.
  * 교통량 제어기(Traffic Controller): 프로세스의 상태에 대한 조사와 통보를 담당.
* 스레드: 프로세스 내에서의 작업 단위. 한 프로세스에 하나의 스레드가 존재하면 단일 스레드, 여러 스레드가 존재하면 다중 스레드라고 함. 프로세스의 일부 특성을 가져 경량(Light Weight) 프로세스라고도 함. 스레드 기반 시스템에서는 스케줄링의 최소 단위로서 프로세스의 역할을 담당함. 동일 프로세스 환경에서 서로 독립적인 다중 수행이 가능.
  * 사용자 수준의 스레드: 사용자가 만든 라이브러리를 사용하여 스레드 운용. 속도는 빠르지만 구현 어려움.
  * 커널 수준의 스레드: 운영체제의 커널에 의한 스레드 운용. 구현이 쉽지만 속도가 느림.
  * 스레드 사용의 장점: 병행성 증가, 성능과 처리율 향상, 기억장소 낭비가 줄어듦, 프로세스 간 통신 향상, 

<br>

### 149. 스케줄링 - B

* 스케줄링: 프로세스가 생성되어 실행될 때 필요한 자원을 할당하는 작업.

  * 장기 스케줄링: 어떤 프로세스가 자원을 차지하도록 할 것인가를 결정하여 준비상태 큐로 보내는 작업. 작업 스케줄링, 상위 스케줄링이라고도 함.
  * 중기 스케줄링: 어떤 프로세스들이 CPU를 할당받을 건인지 결정. 프로세스가 많을 경우 일시 보류시킨 후 활성화해서 부하를 조절.
  * 단기 스케줄링: 프로세스가 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업. 프로세서 스케줄링, 하위 스케줄링이라고도 함. 프로세서 스케줄링과 문맥 교환은 프로세서 스케줄러에 의해 수행됨.
    * **문맥 교환(Context Switching)**: 새로운 프로세스에 CPU를 할당하기 위해 현재 CPU가 할당된 프로세스의 상태 정보를 저장하고 새로운 프로세스의 상태 정보를 설정한 후 CPU를 할당하여 실행되도록 하는 작업.

* 스케줄링의 목적

  * 공정성: 모든 프로세서에 공정하게 할당
  * 처리율 증가: 단위 시간당 프로세스 처리량을 증가
  * CPU 이용률 증가

  * 우선순위 제도: 우선순위가 높은 프로세스를 먼저 실행
  * 오버헤드 최소화, 응답시간 최소화, 반환시간 최소화, 대기시간 최소화, 균형 있는 자원의 사용, 무한 연기 회피

* 프로세스 스케줄링 기법

  * 비선점(Non-Preemptive) 스케줄링: 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗지 못하게 함.
    * 응답 시간의 예측이 용이. 일괄 처리 방식에 적합. 중요한 작업이 중요하지 않은 작업을 기다릴 수도 있음. **FCFS, SJF, 우선순위, HRN, 기한부** 등의 알고리즘이 있음.
  * 선점(Preemptive) 스케줄링: 우선순위가 높은 프로세스를 빠르게 처리. 대화식 시분할 시스템에 사용. 많은 오버헤드를 초래. 선점이 가능하도록 인터럽트용 타이머 클록(Clock)이 필요. **Round-Robin, SRT, 선점 우선순위, 다단계 큐(Multi-level Queue), 다단계 피드백 큐** 등의 알고리즘이 있음.

<br>

### 150. 환경 변수 - C

* 환경 변수: 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임.
  * 변수명과 값으로 구성. 시스템의 기본 정보를 저장. 부모 프로세스에서 상속받고 자식 프로세스에 상속됨. 시스템 환경 변수와 사용자 환경 변수로 구분됨.
* Windows의 환경변수: 명령 프롬포트에서 set을 입력하면 모두 표시됨. %변수명%과 같은 형태.
  * ALLUSERPROFILE, APPDATA, ComSpec, HOMEDRIVE, TEMP, PATH, USERDOMAIN 등
* UNIX/LINUX 환경 변수: set, env, printenv 중 하나를 입력하면 표시됨. $변수명 과 같은 형태.
  * DISPLAY, HOME, LANG, MAIL, PATH, PS1, PWD, TERM, USER 등

<br>

### 151. 운영체제 기본 명령어 - B

* WINDOWS
  * CLI 기본 명령어: DIR(파일목록 표시), TYPE(파일내용 표시), REN(파일이름 변경), MD(디렉터리 생성), CD(디렉터리 위치변경), CLS(화면내용 지움), ATTRIB(파일속성 변경), FORMAT(디스크 표면을 트랙과 섹터로 나누어 초기화), MOVE(파일 이동)
  * GUI 기본 명령어: 마우스로 아이콘 더블클릭, 드래그 등
* UNIX / LINUX
  * CLI 기본 명령어: cat(파일내용 표시), chmod(파일 모드를 변경해 파일 사용 허가 지정), chown(소유자 변경), cp(파일복사), exec(새로운 프로세스 수행), fork(새로운 프로세스 생성), fsck(파일 시스템을 검사), ls(현재 디렉터리 내 파일목록 표시), rm(파일 삭제), mount(기존 파일 시스템에 새로운 파일 시스템을 서브 디렉터리에 연결), wait(하위 프로세스의 종료까지 상위 프로세스를 일시 중지시킴)
  * GUI 기본 명령어: X Windows라는 프로그램을 설치해 GUI 방식으로 운영

<br>

### 152. 인터넷 - A

* 인터넷: TCP/IP 프로토콜을 기반으로 전세계 컴퓨터와 네트워크가 연결된 통신망.
  * 미 국방성의 ARPANET에서 시작. 유닉스 기반. 시간과 장소에 구애받지 않음. 고유한 IP주소. 브리지, 라우터, 게이트웨이 사용. 인터넷의 주가 되는 기간망을 백본(Backbone)이라고 함.
* IP 주소: 숫자로 8비트씩 4부분, 총 32비트로 구성. A~E클래스 존재. ABC 클래스만 네트워크 주소와 호스트 주소 체계를 가짐.
  * A클래스(국가나 대형 통신망), B클래스(중대형 통신망), C클래스(소규모 통신망), D클래스(멀티캐스트용), E클래스(실험적 주소이며 공용되지 않음)
* 서브네팅: 할당된 주소를 다시 여러 작은 네트워크로 나누어 사용. 네트워크 주소와 호스트 주소를 구분하기 위한 비트인 서브넷 마스크를 변경하여 네트워크 주소를 여러 개로 분할. 서브넷 마스크는 각 클래스마다 다르게 사용.
* IPv6: IPv4의 주소 부족 문제를 해결하기 위해 개발. IPv4에 비해 자료 전송 속도가 빠름. 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제 해결. IPv4와 호환이 뛰어남. 주소의 확장성, 융통성, 연동성이 뛰어남. 실시간 흐름 제어로 향상된 멀티미디어 기능 지원. Traffic Class, Flow Level을 이용하여 등급별, 서비스별로 패킷을 구분할 수 있음.
  * 구성: 16비트씩 8부분, 총 128비트로 구성. 각 부분을 16진수로 표현하고 콜론(:)으로 구분.
    * 유니캐스트: 1대1 통신에 이용
    * 멀티캐스트: 1대다 통신에 이용
    * 애니캐스트: 가장 가까이 있는 1대1 통신에 이용
* 도메인 네임: IP주소를 사람이 이해하기 쉬운 문자 형태로 표현. 호스트 컴퓨터 이름, 소속 기관 이름, 소속 기관 조율, 소속 국가명 순으로 구성. 도메인 네임을 IP주소로 변환하는 시스템을 DNS라고 하며 이런 역할을 하는 서버를 DNS 서버라고 함.

<br>

### 153. OSI 참조 모델 - A

* OSI 참조모델(Open System Interconnection): 1~3계층은 하위계층, 4~7계층은 상위계층임.
  * 물리 -> 데이터링크 -> 네트워크 -> 전송 -> 세션 -> 표현 -> 응용
* OSI 참조모델에서의 데이터 단위
  * 프로토콜 데이터 단위(PDU): 동일 계층 간 교환되는 정보의 단위.
    * 물리: 비트
    * 데이터링크: 프레임
    * 네트워크: 패킷
    * 전송: 세그먼트
    * 세션, 표현, 응용: 메세지
  * 서비스 데이터 단위(SDU): 서비스 접근점(SAP)을 통해 상/하위 계층끼리 주고받는 정보의 단위.
* **물리 계층**: 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의. RS-232C, X.21 등. 리피터, 허브.
* **데이터 링크 계층**: 두 개의 인접한 개방 시스템들 간의 정보 전송. 흐름 제어, 프레임 동기화, 오류 제어, 순서 제어 기능. HDLC, LAPB, LLC, MAC, LAPD, PPP 등. 랜카드, 브리지, 스위치.
* **네트워크 계층**: 개방 시스템 간의 네트워크 연결과 데이터 교환. 경로 설정(라우팅), 트래픽 제어, 패킷 정보 전송. X.25, IP 등. 라우터.

* **전송 계층**: 하위계층과 상위계층의 인터페이스 담당. 종단 시스템(End-to-End) 간의 전송 연결 설정, 데이터 전송, 연결 해제 역할. 주소 설정, 다중화(분할 및 재조립), **오류 제어, 흐름 제어**. TCP, UDP 등. 게이트웨이.
* **세션 계층**: 대화 구성 및 동기 제어, 데이터 교환 관리 기능. 대화 동기를 위해 전송하는 정보의 일정한 부분에 체크포인트(동기점)를 두어 정보의 수신 상태를 체크. 동기점은 데이터 회복을 위해 사용.
  * 대동기점: 각 데이터의 처음과 끝에 사용. 수신측으로부터 확인 신호(ACK)를 받음.
  * 소동기점: 한 대화 단위 내에서 데이터 전달을 제어. 확인 신호(ACK)를 받지 않음.
* **표현 계층**: 응용 계층과 세션 계층 간 데이터 변환 기능을 함. 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식(포맷) 변환, 문맥 관리 기능.
* **응용 계층**: 사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스를 제공. 프로세스 간 정보 교환, 전자 사서함, 파일 전송, 가상 터미널 등의 서비스를 제공.

<br>

### 154. 네트워크 관련 장비 - B

* 네트워크 인터페이스 카드(NIC): 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결. 이더넷 카드, 랜카드, 네트워크 어댑터라고도 함.

* 허브(Hub): 가까운 거리의 컴퓨터들을 연결. 리피터 기능도 포함.
  * 더미 허브: 네트워크에 흐르는 모든 데이터를 단순히 연결만 함. LAN이 보유한 대역폭을 컴퓨터 수만큼 나누어 제공. (100MB 대역폭을 5개 컴퓨터에 나누면 대당 20MB)
  * 스위칭 허브: 네트워크에 흐르는 데이터의 유무 및 흐름을 제어하여 각각의 노드가 최대 대역폭을 사용하게 함. 최근 사용 허브는 대부분 스위칭 허브.
* 리피터(Repeater): 약해진 신호를 원래 형태로 재생하여 전송하는 기능. 근접한 네트워크 간 신호를 전송, 전송 거리의 연장 또는 배선의 자유도를 높이기 위한 기능.
* 브리지(Bridge): LAN과 LAN을 연결하거나 LAN 안에서의 세그먼트를 연결. MAC 브리지라고도 함. 트래픽 병목 현상 줄임. 네트워크 분산하여 보안성 높임. 브리지를 이용한 서브넷 구성 시 전송 가능한 회선 수는 브리지가 n개일 때 n(n-1)/2개임.
* 스위치(Switch): LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치. 하드웨어 기반으로 전송 속도가 빠름. 수십에서 수백 개 포트 제공. 포트마다 다른 전송속도 지원하게 할 수 있음.
* 라우터(Router): LAN과 LAN 연결 기능에 최적 경로 선정 기능 추가. LAN과 WAN의 연결도 수행. 1~3계층까지의 프로토콜 구조가 다른 네트워크 간의 연결을 위한 변환 기능을 수행함.
* 게이트웨이(Gateway): 전 계층의 프로토콜 구조가 다른 네트워크의 연결을 수행. 세션, 표현, 응용 계층 간을 연결하여 데이터형식변환, 주소변환, 프로토콜 변환 등을 수행. LAN에서 다른 네트워크와 데이터를 주고받는 출입구 역할.

<br>

### 155. 프로토콜의 개념 - B

* 프로토콜: 서로 다른 기기들 간의 데이터 교환을 수행하기 위한 표준화된 통신규약. 하드웨어, 소프트웨어, 문서를 모두 규정.
  * 기본요소: 구문(데이터 형식, 부호화, 신호 레벨), 의미(통신을 위한 협조 사항과 오류 관리를 위한 제어 정보), 타이밍(두 기기 간 통신 속도, 메세지의 순서 제어 등을 규정)
* 기능
  * 단편화와 재결합: 송신 측에서 데이터를 전송에 알맞은 크기로 분할(단편화) / 수신측에서 원래의 데이터로 모음(재결합). 단편화된 데이터를 프로토콜 데이터 단위(PDU)라고 함. 단편화하면 전송 시간이 빠르고 통신중 오류를 제어할 수 있음. 너무 작은 블록으로 단편화하면 비효율적.
  * 캡슐화(요약화): 단편화된 데이터에 송수신지 **주소, 오류 검출 코드, 프로토콜 제어 정보** 등의 정보를 부가함. 대표적으로 데이터 링크 제어 프로토콜의 HDLC 프레임. 데이터를 오류 없이 정확하게 전송하기 위해 수행.
  * 흐름 제어: 수신 측의 처리능력에 따라 송신측 데이터 전송량이나 전송송도를 조절. Stop-and-Wait, Sliding Window 방식을 이용.
  * 오류 제어: 전송중에 발생하는 오류를 검출하고 정정하여 데이터나 제어 정보의 파손에 대비.
  * 동기화: 송수신측이 같은 상태를 유지하도록 타이밍을 맞추는 기능.
  * 순서 제어: 전송되는 PDU에 전송 순서를 부여. 연결 위주의 데이터 전송 방식에만 사용. 흐름 제어 및 오류 제어를 용이하게 함.
  * 주소 지정: 목적지 이름, 주소, 경로를 부여하는 기능. 
  * 다중화: 한 회선을 여러 가입자가 동시에 사용 가능하게 하는 기능.
  * 경로 제어: 송수신측 간의 송신 경로에서 최적의 패킷 경로를 설정하는 기능.
  * 전송 서비스: 우선순위, 서비스 등급, 보안성

<br>

### 156. TCP/IP - A

* TCP/IP: 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜.

  * TCP: OSI 7계층의 전송 계층. 연결형 서비스 제공. 패킷 다중화, 순서 제어, 오류 제어, 흐름 제어 제공. 스트림 전송 기능 제공. TCP 헤더에는 Source/Destination Port Number, Sequence Number, Acknowledgment Number, Checksum 등이 포함.
  * IP: OSI 7계층의 네트워크 계층. 비연결형 서비스 제공. 패킷 분해/조립, 주소 지정, 경로 선택 기능 제공. 헤더 길이는 20~60바이트. IP 헤더에는 Version, Header Length, Total Packet Length, Header Checksum, Source/Destination IP Address 등이 포함.

* TCP/IP 계층 구조

  |       OSI        |        TCP/IP        |                             기능                             |
  | :--------------: | :------------------: | :----------------------------------------------------------: |
  | 응용, 표현, 세션 |      응용 계층       | 응용 프로그램간 데이터 송수신 제공<br>TELNET, FTP, SMTP, SNMP, DNS, HTTP 등 |
  |       전송       |      전송 계층       |       호스트 간의 신뢰성 있는 통신 제공<br>TCP, UDP 등       |
  |     네트워크     |     인터넷 계층      | 데이터 전송을 위한 주소 지정, 경로 설정을 제공<br>IP, ICMP, IGMP, ARP, RARP 등 |
  | 데이터링크, 물리 | 네트워크 액세스 계층 | 실제 데이터(프레임)를 송수신하는 역할<br>Ethernet, IEEE 802, HDLC, X.25, RS-232C, ARQ 등 |

* 응용 계층의 주요 프로토콜

  * FTP: 파일을 주고받는 원격 파일 전송 프로토콜.
  * SMTP: 전자 우편 교환 서비스.
  * TELNET: 멀리 떨어진 컴퓨터에 접속하여 자신의 컴퓨터처럼 이용 가능하게 하는 서비스. 시스템 관리 작업을 할 수 있는 Virtual Terminal 기능 수행.
  * SNMP: TCP/IP의 네트워크 관리 프로토콜. 라우터나 허브 등 네트워크 기기의 정보를 관리 시스템에 보내는 데 사용.
  * DNS: 도메인 네임을 IP로 매핑하는 시스템.
  * HTTP: WWW에서 HTML 문서를 송수신하기 위한 프로토콜

* 전송 계층의 주요 프로토콜

  * TCP: 양방향 연결(Full Duplex Connection)형 서비스 제공. 가상 회선 연결(Virtual Circuit Connection) 서비스 제공. 순서 제어, 오류 제어, 흐름 제어 기능. 투명성 있는 통신 보장.
  * UDP: 비연결형 서비스 제공. TCP에 비해 단순한 헤더 구조로 오버헤드가 적음. 빠른 속도 필요, 동시에 여러 사용자에게 데이터 전달, 정기적으로 반복해서 보낼 경우에 사용. 실시간 전송에 유리. 신뢰성보다 속도 중요시되는 네트워크에 사용. UDP 헤더에는 Source Port Number, Destination Port Number, Length, Checksum 등이 있음.
  * RTCP: RTP 패킷의 전송 품질을 제어하는 프로토콜. 세션의 각 참여자에게 주기적으로 제어 정보 전송. 하위 프로토콜은 데이터 패킷과 제어 패킷의 다중화를 제공. 데이터 전송 모니터링. 최소한의 제어와 인증 기능만 제공. RTCP 패킷은 항상 32비트의 경계로 끝남.

* 인터넷 계층의 주요 프로토콜

  * IP: 전송할 데이터에 주소를 지정하고 경로를 설정하는 기능. 비연결형인 데이터그램 방식으로 신뢰성이 보장되지 않음.
  * ICMP(Internet Control Message): IP와 조합하여 통신 중 발생하는 오류 처리와 전송 경로 변경 등을 위한 제어 메세지 관리. 헤더는 8바이트.
  * IGMP(Internet Group Management): 멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지.
  * ARP(Address Resolution): 호스트의 IP주소를 호스트와 연결된 네트워크 장치의 MAC 주소로 변경.
  * RARP: MAC 주소를 IP 주소로 변경.

* 네트워크 액세스 계층의 주요 프로토콜

  * Ethernet(IEEE 802.3): CSMA/CD 방식의 LAN.
  * IEEE 802: LAN을 위한 표준 프로토콜.
  * HDLC: 비트 위주의 데이터 링크 제어 프로토콜.
  * X.25: 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스 제공.
  * RS-232C: 공중전화 교환망(PSTN)을 통한 DTE와 DCE 간의 인터페이스 제공.

