### 85. 사전 조사 분석

* 물리 데이터베이스 설계: 논리적 구조의 데이터베이스를 물리적 저장장치에 저장할 수 있도록 변환하는 과정.
  * 기본적인 데이터 단위는 저장 레코드(Record)임.
  * **저장 레코드 양식 설계**, **레코드 집중(Clusturing)의 분석 및 설계**, **접근 경로 설계** 등이 포함돼야 함.
  * 물리적 DB 구조는 DB 시스템의 성능에 중대한 영향을 미침.
  * **설계 시 고려사항**: 인덱스 구조, 레코드 크기와 개수, 트랜잭션의 갱신과 참조 성향, 성능 향상을 위한 개념 스키마의 변경 여부 검토, 빈번한 질의와 트랜잭션들의 수행속도를 높이기 위한 고려, 시스템 운용 시 파일 크기의 변화 가능성
  * 물리 설계 전에 데이터 명명 규칙, 시스템 자원, DB 관리 요소 등을 파악해야 함
* **데이터 명명규칙 파악**: 조직마다 다를 수 있으므로 물리 데이터 모델의 설계 전에 파악해야 함.
  * 데이터 표준화, 논리 데이터베이스 설계의 결과물 등을 통해 파악. 논리 DB 설계에 적용되는 것과 일관성을 유지해야 함.
  * 중복 구축 등을 방지 가능. 명명규칙을 파악하려면 도메인과 데이터 사전에 대한 지식이 필요.
    * 데이터 사전: 데이터 속성의 논리명, 물리명, 용어 정의를 기술해놓은 것. 명칭 부여의 근거로 사용.
* **시스템 자원 파악**: 데이터베이스 설치에 영향을 미칠 수 있는 물리적 요소. 사전에 미리 파악.
  * 하드웨어 자원: CPU(집중적 부하 발생시간 등), 메모리(사용 가능한 메모리 영역 등), 디스크(사용 가능한 공간 등), I/O Controller(입출력 컨트롤러 성능 등), 네트워크(처리량, 속도, 동시 접속 가능정도 등)
  * 운영체제 및 DBMS 버전
  * DBMS 파라미터 정보: 저장공간, 메모리 등에 대한 파라미터, 퀄에서 활용하는 옵티마이저의 사용법 등
* **데이터베이스 관리 요소 파악**: DB 운영과 관련된 요소, 미리 파악해야 함, DB 관리 요소 파악 후 이를 기반으로 DB 시스템 조사 분석서를 작성함.
  * DB 시스템 조사 분석서를 기반으로 다음의 범위와 특성 파악.
    * 데이터베이스 구조
    * 이중화 구성: 문제 발생에 대비해 동일한 DB를 복제하여 관리
    * 분산 데이터베이스: 유실 복구에 대비해 분산 구조 파악
    * 접근제어/접근통제
    * DB암호화

<br>

### 86. 데이터베이스 저장 공간 설계 - B

* 테이블: DB의 가장 기본적인 객체. DB의 모든 데이터는 테이블에 저장됨. 논리적 설계의 개체에 해당. DBMS 종류에 따라 명칭과 기능은 차이 존재.
  * 일반 테이블: 대부분의 DBMS에서 표준으로 사용. Row 위치는 저장되는 순서에 따라 결정. **힙 구조 테이블**이라고도 함.
  * 클러스터드 인덱스 테이블: **기본키나 인덱스키의 순서에 따라 데이터가 저장**. 일반 테이블에 비해 접근 경로가 단축됨.
  * 파티셔닝 테이블: 대용량의 테이블을 작은 논리적 단위인 파티션으로 나눔. 파티션 키를 잘못 구성하면 성능 저하될수도 있음. 
    * 범위 분할: 지정한 열의 값을 기준으로 분할
    * 해시 분할: 해시 함수 결과에 따라 분할
    * 조합 분할: 범위 + 해시
  * 외부 테이블: DB에서 일반 테이블처럼 사용 가능한 외부 파일. DB 내에 객체로 존재. **데이터 웨어하우스**에서 ETL(추출, 변환, 적재) 등의 작접에 유용하게 사용.
  * 임시 테이블: 트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블. 트랜잭션이 종료되면 삭제됨. 절차적 처리를 위해 임시로 생성.
* 컬럼: 데이터 타입, 길이 등으로 정의됨. 도메인을 정의한 경우 도메인에 따라 결정. **두 컬럼을 비교할 때 길이나 타입이 다르면 DB 내부에서 변환하여 비교**함. 참조 관계의 경우 타입과 길이가 일치해야 함.
* 테이블스페이스: 테이블이 저장되는 **논리적 영역**. 하나의 테이블스페이스에 하나 이상의 테이블을 저장 가능.
  * 테이블을 저장하면 논리적으로 테이블스페이스에 저장되고 물리적으로 해당 테이블스페이스와 연관된 데이터 파일에 저장됨.
  * DB를 테이블, 테이블스페이스, 데이터 파일로 나눠 정리하면 논리적 구성이 물리적 구성에 종속되지 않아 투명성이 보장됨.
  * 저장 내용에 따라 테이블, 인덱스, 임시 등의 용도로 구분하여 설계.
  * 설계 시 고려사항: 업무별로 구분하여 지정. 대용량 테이블은 하나의 테이블스페이스에 따로 저장. 테이블과 인덱스는 분리하여 저장.

<br>

### 87. 트랜잭션 분석 / CRUD 분석 - B

* **트랜잭션**: DB의 상태를 변화시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들.
  * DB 시스템의 병행 제어 및 회복 작업 시 작업의 논리적 단위로 사용됨. 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용됨.
* 트랜잭션의 특성(**ACID**): 데이터 무결성을 보장하기 위해 필요함
  * **Atomicity(원자성)**: 트랜잭션은 완전히 반영(Commit)되든지 전혀 반영되지 않도록 복구(Rollback)돼야 함
  * **Consistency(일관성)**: 시스템의 고정 요소는 트랜잭션 전후로 상태가 같아야 함
  * **Isolation(독립성)**: 각 트랜잭션은 완료될 때까지 병행중인 다른 트랜잭션을 참조할 수 없음
  * **Durability(영속성)**: 완료된 트랜잭션 결과는 시스템이 고장나더라도 영구적으로 반영돼야함
* CRUD 분석: **Create, Read, Update, Delete - DB 테이블에 변화를 주는 트랜잭션 연산**
  * 트랜잭션의 주기별 발생횟수, 테이블에 저장되는 데이터 양을 유추해 많은 트랙잭션이 몰리는 테이블을 파악함, 부하가 집중되는 DB 채널을 파악하고 분산시켜 연결 지연이나 타임아웃 오류를 방지
  * CRUD 매트릭스: 업무 프로세스와 데이터 간 상관 분석표
    * 각 셀에는 C, R, U, D가 들어가며 복수 변화를 줄 때는 C > D > U > R 순으로 적음
    * 불필요하거나 누락된 테이블 또는 프로세스를 찾을 수 있음
* 트랜잭션 분석: CRUD 매트릭스를 기반으로 DB용량을 산정하고 DB구조를 최적화함.
  * 업무 개발 담당자가 수행, 디스크 입출력 분산을 통한 성능 향상
* 트랜잭션 분석서: 단위 프로세스와 CRUD 매트릭스를 이용하여 작성
  * 단위 프로세스: 업무를 발생시키는 최소단위의 프로세스
  * CRUD 연산
  * 테이블명, 컬럼명
  * 테이블 참조 횟수
  * 트랜잭션 수
  * 발생 주기

<br>

### 88. 인덱스 설계 - A

* **인덱스**: 데이터 레코드를 빠르게 접근하기 위해 <키값, 포인터> 쌍으로 구성되는 데이터 구조.
  * 포인터는 해당 레코드의 물리적 주소임
  * 하나 이상의 필드로 만들어도 됨
  * 레코드 삽입과 삭제가 수시로 일어날 때는 인덱스 갯수를 최소로 해야 함
  * 인덱스가 없으면 모든 데이터를 확인하는 TABLE SCAN이 발생함
  * 기본키를 위한 인덱스를 기본 인덱스, 그 외를 보조 인덱스라고 함. 대부분 관계형 DBMS에서는 기본 인덱스를 자동으로 생성함
  * 클러스터드 인덱스: 레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성

* **트리 기반 인덱스**: 인덱스를 저장하는 블록들이 트리 구조.
  * B 트리 인덱스: 일반적인 방식. 루트에서 하위로 키값의 크기를 비교하면서 단말노드에서 찾고자 하는 데이터를 검색. 키값과 포인터는 트리 노드에 오름차순으로 정렬. 모든 단말노드는 같은 레벨.
  * B+ 트리 인덱스: 상용 DBMS에서 주로 사용. 노드로 구성된 인덱스 세트와 단말노드로 구성된 순차 세트가 존재. 인덱스 세트는 단말노드의 키값을 찾는 경로, 순차세트가 레코드 주소를 가리킴. 단말노드만을 이용한 순차처리가 가능.
* **비트맵 인덱스**: 인덱스 컬럼의 데이터를 비트값인 0/1로 변환하여 키값으로 사용.
  * 목적은 키값을 포함하는 로우(Row)의 주소를 제공하는 것.
  * 분포도(전체 레코드 중 찾는 레코드가 적은 정도)가 좋은 컬럼에 적합, 성능 향상됨.
  * 데이터가 비트값이기 때문에 효율적인 연산이 가능, 다중 조건을 만족하는 튜플의 갯수 계산에 적합, 동일한 값이 반복되는 경우가 많아 압축 효율이 좋음.
* **함수 기반 인덱스**: 컬럼에 특정 함수나 수식을 적용해 산출된 값을 사용. B+트리 인덱스 또는 비트맵 인덱스를 생성하여 사용.
  * 사용자 정의 함수는 시스템 함수보다 부하가 큼. 대소문자, 띄어쓰기 등에 상관없이 조회할 때 유용.
  * 산술식(Arithmetic Expression), 사용자 정의 함수, PL/SQL Function, SQL Function, Package, C callout 등

* **비트맵 조인 인덱스**: 다수의 조인된 객체로 구성된 인덱스. 일반적인 인덱스와 액세스 방법이 다름. 비트맵 인덱스와 물리적 구조가 동일. 데이터 종류가 적고 동일한 데이터가 많을 때 (**분포도가 낮을 때) 최적의 성능.**
* **도메인 인덱스**: 개발자가 필요한 인덱스를 직접 만들어 사용. 확장형(Extensible) 인덱스라고도 함. 프로그램에서 제공하는 인덱스처럼 쓸 수도 있음.
* 인덱스 설계 순서
  1. 인덱스의 대상 테이블이나 컬럼을 선정
  2. 인덱스의 효율성을 검토하며 인덱스 최적화 수행
  3. 인덱스 정의서 작성

* 인덱스 대상 테이블 선정 기준

  * MULTI BLOCK READ(한번에 읽어들일 수 있는 블록 수) 이상의 인덱스 필요
  * 랜덤 액세스가 빈번한 테이블, 특정 범위나 순서로 조회가 필요한 테이블, 다른 테이블과 순차적 조인이 발생하는 테이블

* 인덱스 대상 컬럼 선정 기준

  * 인덱스 컬럼 분포도가 10% ~ 15% 이내인 컬럼 (분포도: 컬럼값의 평균Row수 / 테이블의 총 Row수 * 100)

  * 분포도가 10~15% 이상이어도 부분 처리를 목적으로 하는 컬럼
  * 입출력 장표 등에서 조회 및 출력 조건으로 사용되는 컬럼
  * 기본키와 Unique 제약조건을 사용한 컬럼 (자동생성)
  * 수정이 빈번하지 않은 컬럼, ORDER BY, GROUP BY, UNION이 빈번한 컬럼
  * 분포도가 좁은 컬럼은 단독 인덱스로 작성, 인덱스들이 자주 조합되어 사용되는 경우 하나의 결합 인덱스로 생성

* 인덱스 설계 시 고려사항

  * 기존 액세스 경로에 영향을 미칠 수 있음, 지나치게 많이 만들거나 넓은 범위를 인덱스로 처리하면 오버헤드 발생, 추가적인 저장공간 필요, 인덱스와 테이블 저장공간이 분리되도록 설계

<br>

### 89. 뷰(View) 설계 - A

* **뷰**: 사용자에게 접근이 허용된 자료만을 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 가상의 테이블.
  * **물리적으로 존재하지 않지만** 사용자에겐 있는 것으로 간주됨. 임시적인 작업을 위한 용도로 활용.
  * 조인의 사용 최소화로 사용 편의성 최대화.
  * 뷰를 생성하면 뷰 정의가 시스템 내에 저장 -> 뷰 이름을 질의어에서 사용하면 정의된 기본 테이블로 대체되어 기본 테이블에 대해 실행됨 (뷰를 통해 테이블 데이터에 접근)
* 특징
  * 기본 테이블과 같은 구조, 유사한 조작법
  * 데이터의 논리적 독립성 제공
  * 관리가 용이하고 명령문이 간단해짐
  * 뷰에 나타나지 않는 데이터를 보호할 수 있음
  * 기본키를 포함한 속성 집합으로 뷰를 구성해야 삽입, 삭제, 갱신 연산이 가능 (**검색은 제한없음**)
  * 한번 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있음, 뷰를 정의한 테이블이나 뷰를 삭제하면 그 뷰를 기초로 한 다른 뷰도 삭제됨
  * 장점: **논리적 데이터 독립성** 제공, 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구 지원, 사용자의 데이터 관리를 간단화, **접근 제어**를 통한 자동 **보안**
  * 단점: **독립적인 인덱스를 못 가짐**, 뷰의 정의 변경 불가, **삽입, 삭제, 갱신 연산에 제약**
* 뷰 설계 순서
  1. 대상 테이블 선정: 외부 시스템과 인터페이스에 관여하는 테이블, CRUD 매트릭스 참조 - 자주 조인되는 테이블, SQL에서 인라인 뷰(FROM 절에 사용되는 거)로 자주 접근되는 테이블
  2. 대상 컬럼 선정: 보안 유지해야 하는 컬럼은 주의
  3. 정의서 작성: 뷰명, 뷰 설명, 관련 테이블, 관련 컬럼, 데이터 타입
* 설계시 고려 사항
  * 테이블 구조가 단순화되도록 반복적으로 조인이 사용 or 동일한 조건절을 사용하는 테이블을 뷰로 생성
  * 사용할 데이터를 다양한 관점에서 제시
  * 데이터 보안 유지

<br>

### 90. 클러스터 설계 - A

* **클러스터**: 데이터 저장 시 액세스 효율 향상을 위해 동일 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법.
  * 클리스터링 키로 지정된 컬럼 값이 순서대로 저장되고 여러 테이블이 하나의 클러스터에 저장됨.
* 특징
  * 조회성능은 향상되지만 입력, 수정, 삭제 성능은 저하됨
  * 데이터 분포도가 넓을수록 유리함 (인덱스와 반대)
     -> 저장공간을 절약할 수 있음 (클러스터링키 열을 공유하기 때문)
  * 대용량을 처리하는 트랜잭션은 전체 테이블을 자주 스캔하므로 클러스터링을 안하는게 좋음
  * 처리 범위가 넓은 경우 단일 클러스터링, 조인이 많이 발생하는 경우 다중 클러스터링 사용
  * 파티셔닝 된 테이블에는 클러스터링할 수 없음
  * 비슷한 데이터가 동일한 데이터 블록에 저장되기 때문에 디스크 I/O가 줄어듦
  * 클러스터링 테이블에 클러스터드 인덱스를 생성하면 접근 성능이 향상
* 대상 테이블
  * 분포도가 넓은 테이블, 대량의 범위를 자주 조회하는 테이블
  * 입력, 수정, 삭제가 자주 발생하지 않는 테이블, 자주 조인되는 테이블
  * ORDER BY, GROUP BY, UNION이 빈번한 테이블

<br>

### 91. 파티션 설계 - A

* 파티셔닝: 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것.
  * 성능저하 방지, 데이터 관리 쉬워짐
  * 테이블이나 인덱스를 파티셔닝하면 파티션키(파티션을 나누는 기준이 되는 열) 또는 인덱스키에 따라 물리적으로 별도의 공간에 데이터가 저장됨
  * 데이터 처리는 테이블 단위로 처리되고(애플리케이션은 파티션을 인식 못함) 데이터 처리는 파티션별로 수행됨
  * 장점: 데이터 접근 시 액세스 범위를 줄여 쿼리 성능 향상, 디스크 성능 향상, 파티션별로 백업 및 복구를 수행하므로 속도빠름, 시스템 장애 시 데이터 손상 최소화, 데이터 가용성 향상, 파티션 단위로 입출력 분산
  * 단점: **조인 비용 증가**, **작은 테이블에 수행하면 오히려 성능 저하**
* 종류
  * 범위 분할(Range): 지정한 열의 값을 기준으로 분할. (월별, 분기별 등) 특정 파티션에 데이터가 집중됨.
  * 해시 분할(Hash): 해시 함수를 적용한 결과에 따라 분할. 데이터가 고르게 분산. 특정 데이터가 어딨는지 모름. 고객번호, 주민번호 등 데이터가 고른 컬럼에 효과적.
  * 조합 분할(Composite): 범위 분할 + 해시 분할. 범위분할한 파티션이 너무 클때 사용.
* 파티션키 선정 시 고려사항
  * 테이블 접근 유형에 따라 파티셔닝이 이뤄지도록 선정. 이력성 데이터는 파티션 생성주기와 소멸주기를 일치시켜야 함. 매일 생성되는 날짜 컬럼, 백업의 기준이 되는 날짜 컬럼, 파티션 간 이동이 없는 컬럼, I/O 병목을 줄일 수 있는 데이터 분포가 양호한 컬럼 등을 파티션키로 선정.
* 인덱스 파티션: 파티션된 데이터를 관리하기 위해 인덱스를 나눈 것.
  * 종속 여부에 따른 분류
    * **Local** Partitioned Index: 테이블/인덱스 파티션이 **1:1** 대응. **Global보다 데이터 관리 쉬움**
    * **Global** Partitioned Index: 테이블/인덱스 파티션이 **독립적**으로 구성
  * 파티션키 컬럼 위치에 따른 분류
    * Prefixed Partitioned Index: 인덱스 파티션키와 인덱스 첫번째 칼럼이 같음.
    * Non-Prefixed Partitioned Index: 다름.

<br>

### 92. 데이터베이스 용량 설계 - C

* 데이터베이스 용량 설계: 물리 DB 설계 과정에서 데이터가 저장될 공간을 정의.
  데이터양, 인덱스, 클러스터 등이 차지하는 공간을 예측해 반영해야 함.

* 목적
  * 디스크 저장공간을 효과적으로 사용하고 확장성, 가용성 늘림, 테이블과 인덱스에 적합한 저장옵션 지정
  * 디스크 입출력 부하를 분산시키고 채널의 병목현상 최소화 -> 접근성 향상
    * 테이블과 인덱스의 테이블스페이스 분리
    * 테이블스페이스와 임시 테이블스페이스 분리
    * 테이블을 마스터 테이블과 트랜잭션 테이블로 분리
  * DB에 생성되는 오브젝트의 익스텐트 발생을 최소화해 성능 향상

* 절차
  1. 데이터 예상 건수, 로우길이, 보존기간, 증가율 등 기초 자료를 수집해 용량 분석
  2. 분석자료를 바탕으로 DBMS에 이용될 테이블, 인덱스 등 오브젝트별 용량을 선정
  3. 테이블과 인덱스의 테이블스페이스 용량을 산정(생성된 테이블 용량의 총합 + 40% 정도 추가)
  4. DB에 저장될 모든 데이터 용량과 DB 설치 및 관리를 위한 시스템 용량을 합해 디스크 용량 산정

<br>

### 93. 분산 데이터베이스 설계 - A

* 분산 데이터베이스: 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크로 연결된 여러 컴퓨터 사이트에 분산된 데이터베이스.
* 구성요소
  * **분산 처리기**: 자체적인 처리능력을 가지는, 분산되어 있는 컴퓨터
  * **분산 데이터베이스**: 분산된 환경에 맞게 구성
  * **통신 네트워크**

* 고려사항: 작업부하의 노드별 분산, 지역의 자치성, 데이터 일관성, 회복기능, 원격접근기능
* 목표
  * 위치 투명성(Location): 데이터 실제 위치는 몰라도 됨, 논리적 DB명만으로 액세스 가능
  * 중복(복제) 투명성(Replication): 동일 데이터가 여러곳에 중복이라도 시스템은 자동으로 여러 자료에 작업 수행
  * 병행 투명성(Concurrency): 다수의 트랜잭션이 동시 실행돼도 서로 영향주지 않음
  * 장애 투명성(Failure): 장애가 있어도 트랜잭션 처리
* 장점: 자료 **공유성 향상**, 분산제어, 시스템성능, 중앙컴퓨터 장애가 시스템 전체에 영향주지 않음, 시스템 용량 **확장 용이**
* 단점: DBMS가 수행할 기능 복잡, DB 설계 어려움, **비용 증가**, **오류 증가**

* 분산 데이터베이스 설계: 잘못 설계되면 복잡성과 비용 증가, 속도 저하 일어남. 전역 관계망을 논리적 소규모 단위(Fragment, 분할)로 분할하여 복수의 노드에 할당함.
  * 테이블 위치 분산: 테이블을 각기 다른 서버에 분산배치. 테이블 구조는 안바꿈. 해당 테이블이 놓일 서버를 미리 설정해야 함.
  * 분할(Fragment): 테이블의 데이터를 분할하여 분산
    * 완전성(Completemness): 전체 데이터를 대상으로 분할
    * 재구성(Reconstruction)
    * 상호 중첨 배제(Dis-jointness): 서로 다른 분할의 항목에 속하면 안됨
    * 수평분할, 수직분할: 행, 컬럼 단위로 분할
  * 할당(Allocation): 동일한 분할을 여러 서버에 저장
    * 비중복 할당 방식: 최적 노드를 택해 분산DB의 단일 노드에만 존재하게 할당. 의존성 무시되고 비용 증가, 성능 저하 등 문제 발생
    * 중복 할당 방식: 부분 복제 / 완전 복제

<br>

### 94. 데이터베이스 이중화 / 서버 클러스터링 - B

* 데이터베이스 이중화(Replication): 동일한 DB 복제해서 관리하는거
  * 사용자가 수행하는 작업이 이중화로 연결된 다른 DB에도 적용됨
  * DB 부하를 줄일 수 있음, 쉽게 백업서버 운영가능
  * 분류
    * Eager 기법: 트랜잭션 수행 중 데이터 변경되면 모든 이중화 DB에 적용
    * Lazy 기법: 트랜잭션 종료 후 변경 사실을 새 트랜잭션으로 작성하여 이중화 DB에 전달
  * 구성방법
    * Active-Standby(활동-대기), Active-Active(활동-활동)
* **클러스터링**: 두대 이상의 서버를 하나처럼 운영하는 기술
  * 서버 이중화 및 공유 스토리지를 이용해 고가용성 제공
  * **고가용성 클러스터링**: **한 서버에 장애 발생하면 다른 노드(서버)가 받아 처리**하여 서비스 중단 방지
  * **병렬 처리 클러스터링**: 한 작업을 **여러 서버에서 분산** 처리

<br>

### 95. 데이터베이스 보안 / 암호화 - B

* 데이터베이스 보안: 권한이 없는 사용자의 액세스 금지

  * 무결성은 권한이 있는 사람으로부터 DB를 보호하는 것, 정확성 보장

* 암호화: 데이터 송신자가 지정한 수신자 이외에는 내용을 알 수 없게 하는거

  * 암호화(Encryption), 복호화(Decryption)

  * 개인키 암호 방식(Private): 동일한 키로 데이터를 암호화하고 복호화. 전위 기법, 대체 기법, 대수 기법, 합성 기법(DES, LUCIFER).. (=비밀키, 단일키, 대칭 암호 방식)
  * 공개키 암호 방식(Public): 암호화 키는 DB 사용자에게 공개하고 복호화 키는 비밀리에 관리함. RSA...

<br>

### 96. 데이터베이스 보안 / 접근통제 - A

* 접근통제: 비안가된 사용자의 접근 감시, 접근 요구자의 사용자 식별, 접근 요구의 정당성 확인 및 기록, 보안 정책에 근거한 접근의 승인 및 거부 활동
  * 임의 접근통제(DAC): 사용자의 신원에 따라 권한 부여. 통제권한이 주체에게 있음. 객체를 생성한 사용자가 객체에 대한 권한을 부여받고 타인에게 허가도 가능. SQL 명령어는 GRANT(부여), REVOKE(취소) 존재.
  * 강제 접근통제(MAC): 주체와 객체의 등급을 비교해 권한 부여. 제3자가 권한을 지정. DB 객체별, 사용자별로 등급 부여 가능. 등급이 높은 객체는 읽기, 쓰기, 수정 불가. 동등한 객체는 읽기, 쓰기, 수정 가능. 낮은 객체는 읽기 가능.
* 접근통제 3요소
  * **정책**: 어떤 주체가 언제 어디서 어떤 객체에게 어떤 행위에 대한 **허용 여부를 정의**
    * 신분 기반 정책: 주체나 그룹의 신분에 근거. IBP(개인에게 허가), GBP(그룹에게 허가)
    * 규칙 기반 정책: 주체의 권한에 근거. MLP(사용자, 객체별), CBP(집단별)
    * 역할 기반 정책: GBP의 변형. 주체의 역할에 근거해 권한 부여.
  * **매커니즘**: 접근통제 정책을 구현하는 **기술적 방법**
    * 접근통제 목록: 객체를 기준으로 어떤 주체가 어떤 행위를 할 수 있는지 기록
    * 능력 리스트: 주체에게 허락된 자원 및 권한 기록
    * 보안 등급: 주체나 객체에 부여된 등급
    * 패스워드
    * 암호화: 데이터 보낼때 지정된 수신자 이외에는 알 수 없도록
  * **보안 모델**: 정책 구현을 위한 **정형화된 모델**
    * **기밀성** 모델: 인가된 사용자만 **접근**. 기밀 보장 최우선. 군대 시스템 등. 
      * 단순 보안 규칙: 높은 등급 객체 못읽음.
      * 스타-보안 규칙: 낮은 등급 객체에 못씀.
      * 강한 스타-보안 규칙: 등급이 다른 객체를 읽거나 쓸수 없음.
    * **무결성** 모델: 인가된 사용자만 **수정**. 불법적인 정보 변경 방지. (인가된 사용자만 수정)
      * 단순 무결성 원칙: 자기보다 낮은 등급 객체 못읽음.
      * 스타-무결성 원칙: 높은 등급 객체에 못씀.
    * 접근통제 모델: 접근통제 매커니즘 강화. 접근통제 행렬(Access Control Matrix)이 있음.
      * 접근통제 행렬: 행은 주체, 열은 객체로 각 객체에 대한 주체별로 권한 나타냄.
* 접근통제 조건: 값 종속 통제, 다중 사용자 통제, 컨텍스트 기반 통제(특정 시간, 주소, 경로, 인증 등에 근거)

* 감사 추적: 애플리케이션이 데이터베이스에 접근하여 수행한 모든 활동을 기록

<br>

### 97. 데이터베이스 백업 - C

* 장애 유형
  * 사용자 실수, 미디어 장애(하드웨어), 구문 장애(프로그램 오류나 공간부족), 사용자 프로세스 장애(비정상종료, 네트워크이상), 인스턴스 장애(비정상 요인으로 인해 프로세스 중단)
* 로그 파일: 트랜잭션 시작, 롤백, 데이터 입력, 수정, 삭제 시점에 기록. 시간 흐름에 따라 기록(작업순서X)
  * 트랜잭션 내용, 트랜잭션 식별, 트랜잭션 레코드, 데이터 식별자, 갱신 이전 값, 갱신 이후 값
* 데이터베이스 복구 알고리즘
  * NO-UNDO/REDO: 비동기적으로 갱신한 경우. 취소할 필요 없고 다시 실행해야 함.
  * UNDO/NO-REDO: 동기적으로 갱신한 경우. 취소하고 다시 실행할 필요 없음.
  * UNDO/REDO: 동기/비동기적으로 갱신한 경우.
  * NO-UNDO/NO-REDO: 동기적으로 저장하지만 다른 영역에 기록한 경우.
* 백업 종류
  * 물리 백업: DB파일 백업. 빠름. 단순. 문제 해결 어려움. 로그 파일 백업하면 완전 복구 가능.
  * 논리 백업: DB 논리적 객체 백업. 문제 해결 쉽지만 백업/복원시 시간 오래걸림. 백업 시점까지 복구.

<br>

### 98. 스토리지 - B

* 스토리지: 단일 디스크로 처리할 수 없는 대용량 데이터를 저장하기 위해 서버와 저장장치 연결
  * **DAS**: 서버와 저장장치를 **케이블로 연결**, 빠르고 쉽고 쌈, 다른 서버에 접근불가, **확장성 유연성 떨어짐**
  * **NAS**: **네트워크**로 연결, NAS Storage가 저장장치 직접 관리, Ethernet 스위치 이용해 다른 서버에 파일 공유 가능, 확장성 유연성 우수, **접속 많아지면 성능저하**
  * **SAN**: DAS + NAS. 서버와 저장장치 연결하는 **전용 네트워크** 구성. **파이버채널(FC) 스위치 이용(광케이블)**. 확장성, 유연성, 가용성 높음. 높은 트랜잭션 처리에 효과적. 비쌈.

<br>

### 99. 논리 데이터 모델의 물리 데이터 모델 변환 - A

* 엔티티를 테이블로 변환: 변환 후 테이블 목록 (정의서) 작성 
  * 엔티티명과 테이블명 동일하게, 엔티티명은 주로 한글이지만 테이블명은 영어로, 메타데이터 관리 시스템에 표준화된 용어가 있을 경우 등록된 단어 사용
* 슈퍼타입/서브타입을 테이블로 변환: 논리 데이터 모델에서 이용되는 형태이므로 테이블로 변환해야 함
  * **슈퍼타입 기준 하나의 테이블로 변환**: 서브타입에 속성, 관계가 적을 때 적용
    * 장점: 액세스 용이, 속도 빠름, 뷰를 이용해 서브타입만 접근가능, SQL 단순해짐
    * 단점: 저장공간 증가, 처리마다 서브타입의 TYPE 구분이 필요함, 인덱스 크기 증가로 효율 저하
  * **서브타입 기준 여러 테이블로 변환**: 서브타입에 속성, 관계가 많을 때 적용
    * 장점: 각 서브타입별 속성들의 선택 사양이 명확할때 유리, 테이블당 크기 감소하여 전체 테이블 스캔 시 유리
    * 단점: 속도 감소, 복잡한 SQL 어려움, 부분 범위 처리가 힘듦, 식별자 유지 관리 어려움, 여러 테이블을 통합한 뷰는 조회만 가능
  * **슈퍼타입과 서브타입을 각각의 테이블로 변환**: 1:1. 전체 데이터 처리가 빈번한 경우, 서브타입 처리가 독립적으로 발생하는 경우, 통합하는 테이블의 컬럼 수가 많은 경우, 서브타입 컬럼 수가 많은 경우, 트랜잭션이 주로 슈퍼타입에 발생하는 경우, 단일 테이블 클러스터링이 필요한 경우
    * 장점: 저장공간 적음. SQL문 작성 용이
    * 단점: 슈퍼타입과 서브타입을 같이 처리할때 항상 조인이 발생해 성능 저하
* 속성을 컬럼으로 변환
  * 일반 속성 변환: 표준화된 **약어 사용**, 가능한 **짧게**, **예약어 X**, 한 로우에 해당하는 샘플 데이터를 작성해 정합성 검증
  * Primary UID(주식별자, 외부식별자)를 기본키로 변환. Secondary(Alternate) UID를 유니크키로 변환
* 관계를 외래키로 변환: 관계는 기본키와 이를 참조하는 외래키로 변환
  * N:M 관계의 경우 양쪽 테이블의 기본키를 모두 포함한 별도의 테이블로 표현
* 관리 목적의 테이블/컬럼 추가: 시스템 등록일자, 시스템 번호 등 관리나 수행속도 향상을 위해 추가
* 데이터 타입 선택: 최적의 데이터타입, 최대의 길이 선택
  * CHAR(고정길이 2000바이트), VARCHAR2(가변길이 4000바이트), NUMBER(38자릿수), DATE(날짜)

<br>

### 100. 물리 데이터 모델 품질 검토 - C

* 품질기준: 정확성(표기법), 완전성(누락X), 준거성(표준,규칙,법), 최신성, 일관성, 활용성

* 순서
  1. 데이터 품질 및 정책기준 확인
  2. 품질 기준 작성
  3. 체크리스트 작성
  4. 논리데이터 모델과 물리데이터 모델 비교
  5. 각 모델링 단계 모델러와 이해관계자가 품질 검토
  6. 5에서 작성한 체크리스트 종합하여 보고서 작성