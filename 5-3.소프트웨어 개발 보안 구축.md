### 179. Secure SDLC - A

* Secure SDLC: SDLC(소프트웨어 개발 생명주기)에 보안 강화를 위한 프로세스를 포함한 것. 소프트웨어 유지 보수 단계에서 보안 이슈 해결에 소모되는 비용을 최소화하기 위해 등장. 대표적으로 Secure Software의 CLASP, Microsoft의 SDL이 있음. 
* 요구사항 분석 단계: 전산화되는 정보가 갖고 있는 보안수준을 등급 매겨 분류. 보안 정책의 출처, 요구 수준, 세부 내용 등을 문서화.
  * 보안 요소: 기밀성(Confidentiality, 인가자만 접근), 무결성(Integrity, 인가자만 수정), 가용성(Availability, 인가자는 언제든 이용가능), 인증(Authentication, 합법적 사용자인지 확인), 부인 방지(NonRepudiation, 송수신 증거 제공)
* 설계 단계: 식별된 보안 요구사항을 설계서에 반영하고 보안 설계서 작성. 위협을 식별하여 보안대책, 소요예산, 사고 시 영향 범위와 대응책 등을 수립. 각 환경에 대한 보안통제 기준 수립.
  * 네트워크: 네트워크 분리, 방화벽 설치
  * 서버: 보안 운영체제, 업데이트, 외부접속 접근통제
  * 물리적 보안: 출입통제, 개발공간 제한, 폐쇠회로
  * 개발 프로그램: 비허가 프로그램 통제, 지속적 데이터 무결성 검사
* 구현 단계: 표준 코딩 정의서 및 소프트웨어 개발 보안 가이드를 준수. 지속적인 단위 테스트. 시큐어 코딩.
* 테스트 단계: 설계 단계에 작성한 보안 설계서의 사항들이 잘 반영됐는지 테스트. 동적 분석 도구 또는 모의 침투테스트. 모든 결과는 문서화하여 보존.
* 유지보수 단계: 보안사고 식별, 보안 패치

<br>

### 180. 세션 통제 - B

* 세션: 서버와 클라이언트의 연결
* 세션 통제: 세션 연결로 인해 발생하는 정보를 관리. 요구사항 분석 및 설계 단계에서 진행.
  * 불충분한 세션 관리: 일정한 규칙이 존재하는 세션ID가 발급되거나 타임아웃이 너무 길때 세션 하이재킹 등 공격이 발생.
  * 잘못된 세션에 의한 정보 노출: 멀티 스레드 환경에서 멤버 변수에 정보를 저장할 때 발생. 싱글톤 패턴에서 발생하는 레이스컨디션으로 인해 동기화 오류가 발생하거나 멤버 변수의 정보가 노출. 멤버 변수보단 지역 변수를 활용해 방지.
* 세션 설계시 고려사항
  * 시스템 모든 페이지에서 로그아웃이 가능하도록 UI 구성. 로구아웃 요청시 해당 세션 제거.
  * 세션 타임아웃은 중요도가 높으면 2~5분, 낮으면 15~30분으로 설정.
  * 이전 세션이 종료되지 않으면 새 세션이 생성되지 못하게 설계.
  * 중복 로그인을 허용하지 않은 경우 클라이언트의 중복 접근에 대한 정책 수립.
  * 패스워드 변경 시 활성화된 세션을 삭제하고 재할당.
* 세션 ID 관리방법: 안전한 서버에서 최소 128비트 길이로 생성. 예측이 불가능하도록 난수 알고리즘 적용. 노출되지 않도록 URL Rewrite 기능을 사용하지 않음. 로그인 시 로그인 전의 세션ID를 삭제하고 재할당. 장기간 접속하고 있는 세션ID는 주기적으로 재할당.

<br>

이하 181~187(~API 오용)은 구현 단계에서의 점검 항목임.

### 181. 입력 데이터 검증 및 표현 - B

* 입력 데이터로 인해 발생하는 문제를 예방하기 위해 **구현 단계**에서 검증할 보안 점검 항목. 유효성 검증, 지정된 자료형 확인, 일관된 언어셋 사용 등.
  * SQL 삽입: 동적 쿼리에 사용되는 입력 데이터에 예약어 및 특수문자를 필터링.
  * 경로 조작 및 자원 삽입: 데이터 입출력 경로를 조작하여 서버 자원을 수정, 삭제하는 약점. 경로 순회 공격을 막는 필터 사용.
  * XSS(크로스사이트 스크립팅): 웹페이지에 악의적인 스크립트를 삽입하는 약점. <, >, & 등의 문자를 치환.
  * 운영체제 명령어 삽입: 시스템 명령어가 전달되지 않도록 하고 외부 입력값을 검증 없이 내부 명령어로 사용하지 않도록 함.
  * 위험한 형식 파일 업로드: 파일 확장자 제한, 파일명 암호화, 웹사이트와 파일 서버의 경로 분리, 실행 속성을 제거.
  * 신뢰되지 않는 주소로 URL 자동접속: 연결되는 외부 사이트 주소를 화이트 리스트로 관리.

### 182. 보안 기능 - B

* 구현 단계에서 코딩하는 기능인 인증, 접근제어, 기밀성, 암호화 등을 점검.
  * 적절한 인증 없이 중요기능 허용: 중요정보나 기능을 수행하는 페이지에서 재인증 수행.
  * 부적절한 인가: 모든 실행경로에 대해 접근제어 검사. 사용자에게 반드시 필요한 접근 권한만 부여.
  * 중요한 자원에 대한 잘못된 권한 설정: 소프트웨어 관리자만 자원을 읽고 쓸 수 있도록 설정. 인가되지 않은 사용자의 자원 접근 여부를 검사.
  * 취약한 암호화 알고리즘 사용: 보안인증사무국이 안정성을 확인한 암호모듈 사용.
  * 중요정보 평문저장 및 전송: 중요한 정보는 암호화. HTTPS 또는 SSL 등 보안 채널을 이용.
  * 하드코드된 비밀번호: 패스워드는 암호화하여 별도 파일에 저장. 디폴트 패스워드나 키의 사용을 피함.

<br>

### 183. 시간 및 상태 - C

* 동시 수행을 지원하는 병렬 처리 시스템이나 다수의 프로세스가 동작하는 환경의 점검 항목. 
  * TOCTOU 경쟁조건: 검사 시점(Time Of Check)과 사용 시점(Time Of Use)을 고려하지 않은 경우 발생. 검사 시점에 사용 가능한 자원이 사용 시점에 사용이 불가능한 경우. 동기화 오류, 교착 상태 등이 발생. 코드 내에 동기화 구문을 사용해 해결.
    * 경쟁조건(레이스컨디션): 둘 이상의 프로세스가 공용 자원을 사용하기 위해 동시에 경쟁하며 접근.
  * 종료되지 않는 반복문 도는 재귀함수: 재귀함수 수행 횟수를 제한하거나 종료 조건을 점검.

<br>

### 184. 에러처리 - B

* 발생할 수 있는 오류를 사전에 정의하여 문제 예방. 예외처리 구문. 
  * 오류 메세지를 통한 정보노출: 실행환경, 사용자 정보, 디버깅 정보 등이 노출되는 문제. 예외처리 구문에 예외 이름이나 스택 트레이스를 출력하도록 코딩하면 발생함. 오류 발생시 가능한 내부에서 처리하거나 최소한의 정보만 출력되도록 해서 방지.
  * 오류 상황 대응 부재: 예외처리를 하지 않았을 때 발생. 소프트웨어 실행이 중단되거나 의도치 않은 동작. 오류가 발생할 수 있는 부분에 예외처리 구문 작성하고 제어문을 활용하여 오류가 악용되지 않도록 코딩.
  * 부적절한 예외처리: 반환값이 의도대로 출력되는지 확인하고 세분화된 예외처리를 수행.

<br>

### 185. 코드 오류 - B

* 형변환, 자원 반환 등의 오류를 예방하기 위한 점검 항목.
  * 널 포인터 역참조: 많은 함수가 오류 발생시 널 값을 반환하는데, 이 반환값을 보인터로 참조할 경우 발생하는 문제. 사전에 널 값을 갖고 있는지 검사.
  * 부적절한 자원 해제: 자원을 반환하는 코드를 누락하거나 반환하지 못했을 때 발생. 힙 메모리, 소켓 등 유한한 시스템 자원이 계속 점유됨. 자원 반환 코드가 누락되었는지 확인하고 예외처리에 관계없이 자원이 반환되도록 코딩.
  * 해제된 자원 사용: 반환된 메모리에 접근할 수 없도록 포인터를 초기화.
  * 초기화되지 않은 변수 사용: 변수 선언 시 할당된 메모리를 초기화.

<br>

### 186. 캡슐화 - C

* 정보 은닉이 필요한 데이터와 기능을 불충분하게 캡슐화하거나 잘못 사용하여 발생.
  * 잘못된 세션에 의한 정보 노출: 멀티스레드 환경에서 멤버변수에 정보를 저장할 때 발생. 지역변수 사용해서 방지.
  * 제거되지 않고 남은 디버그 코드:  디버그 코드를 이용해 인증 및 식별 절차를 우회할수도 있음. 소프트웨어 배포 전에 코드 검사를 통해 남아있는 디버그 코드를 삭제.
  * 시스템 데이터 정보 노출: 시스템 메시지는 최소한의 정보만을 제공하도록 함.
  * Public 메소드에서 반환된 Private 배열: 배열의 주소가 외부로 공개되어 접근 가능하게 됨. 별도의 메소드로 조작하거나 동일한 형태의 복제본으로 반환받은 후 값을 전달하여 방지.
  * Private 배열에 Public 데이터 할당: 레퍼런스가 아닌 값을 직접 지정함으로써 방지.

<br>

### 187. API 오용 - C

* 구현 단계에서 API를 잘못 사용하거나 보안에 취약한 API를 사용했을 때 발생. 
  * DNS Lookup에 의존한 보안결정: 도메인명에 의존하여 인증이나 접근 통제 등의 보안 결정을 내릴 경우 발생. DNS 엔트리를 속여 동일 도메인에 속한 것처럼 위장하거나 사용자와 서버 간 네트워크 트래픽을 조작해 악성 사이트를 경유하도록 조작 가능함. DNS 검색을 통해 메인 이름을 비교하지 않고 IP 주소를 직접 입력하여 접근함으로써 방지할 수 있음.
  * 취약한 API 사용: C언어의 문자열 함수 strcat(), strcpy(), sprintf() 등이 보안 문제로 금지됨. 보안상 안전한 API라도 자원에 대한 직접 연결이나, 네트워크 소켓을 통한 직접 호출과 같이 보안에 위협적인 인터페이스를 사용해도 발생. 안전한 함수로 대체하고 API 매뉴얼을 참고하여 보안이 보장되는 인터페이스를 사용.

<br>

### 188. 암호 알고리즘 - A

* 암호화 방식
  * 양방향
    * 개인키: Stream 방식, Block 방식
    * 공개키
  * 단방향: HASH
* 개인키 암호화 기법: 동일한 키로 데이터를 암호화하고 복호화함.
  * 블록 암호화: 한번에 하나의 데이터 블록을 암호화함. DES, SEED, AES, ARIA 등
  * 스트림 암호화: 평문과 동일한 길이의 스트림을 생성해 비트 단위로 암호화. LFSR, RC4 등
  * 장점: 암호화/복호화 속도 빠름. 알고리즘 단순. 공개키 알고리즘보다 파일 크기 작음.
  * 단점: 사용자 증가에 따라 관리할 키가 증가.
* 공개키 암호화 기법: 암호화에 공개키, 복호화에 비밀키를 사용. 공개키는 데이터베이스 사용자에게 공개하고 비밀키는 관리자가 관리. 비대칭 암호화라고도 함. 대표적으로 RSA 기법이 있음.
  * 장점: 키 분배가 용이. 관리할 키의 개수가 적음.
  * 단점: 암호화/복호화 속도 느림. 알고리즘 복잡. 파일 크기 큼.
  * 공개키 기반 구조: X.509방식(인증기관에서 발생하는 인증서 기반)과 비X.509방식(국가별, 지역별로 보완 및 개발)이 있음.
* 양방향 알고리즘 종류
  * SEED: 1999년 한국인터넷진흥원(KISA). 블록 크기 128비트, 키 길이에 따라 128, 256으로 분류.
  * ARIA: 2004년 국가정보원과 산학연협회. 블록 크기 128비트, 키 길이에 따라 128, 192, 256으로 분류.
  * DES: 1975년 미국 NBS. 블록 크기 64비트, 키 길이 56비트.
  * AES: 2001년 미국 표준기술 연구소(NIST). 블록 크기 128비트, 키 길이에 따라 128, 192, 256으로 분류.
  * RSA: 1978년 MIT. 공개키. 큰 숫자는 소인수분해가 어려움.
* 해시(hash): 임의의 길이의 입력값을 고정 길이의 값으로 변환. 데이터 암호화, 무결성 검증, 정보보호 등.
  * SHA 시리즈, MD5, N-NASH, SNEFRU 등이 있음.