### 61. 애플리케이션 테스트 - B

* 애플리케이션 테스트: 애플리케이션에 잠재된 결함을 찾아내는 일련의 과정.
  * 개발된 소프트웨어가 고객의 **요구사항을 만족**하는지 **확인(Validation)**하고 소프트웨어가 **기능을 정확히 수행**하는지 **검증(Verification)**한다.
  * 사전 오류 예방, 제품 신뢰도 향상, 새로운 오류 유입 방지
* 애플리케이션 테스트 기본 원리
  * 완벽한 테스트 불가능
  * **결함 집중(Defect Clusturing)**: 결함은 대부분 특정 모듈에 집중됨 **(파레토 법칙, Pareto Principle)**
  * **살충제 패러독스(Pesticide Paradox)**: 동일한 테스트케이스로 동일한 테스트를 반복하면 더이상 결함이 발견되지 않는 현상.
  * 테스팅은 **정황(Context)** 의존: 소프트웨어 특징, 테스트 환경, 테스터 역량 등에 따라 결과 다름
  * **오류-부재의 궤변(Absence of Errors Fallacy)**: 결함을 모두 제거해도 사용자 요구사항을 만족하지 못함
  * 테스트와 위험은 반비례
  * 테스트의 점진적 확대: 작은 부분에서 큰 부분으로
  * 테스트의 별도 팀 수행: 개발과 관계없는 팀에서 진행

---

### 62. 애플리케이션 테스트의 분류 - B

* 프로그램 실행 여부에 따른 분류
  * 정적 테스트: 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트. 워크스루, 인스펙션, 코드 검사..
  * 동적 테스트: 프로그램을 실행하여 오류를 찾는 테스트. 블랙박스 테스트, 화이트박스 테스트..
* 테스트 기반에 따른 분류
  * 명세 기반 테스트: 사용자 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 확인하는 테스트. 동등 분할, 경계 값 분석..
  * 구조 기반 테스트: 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트. 구문 기반, 결정 기반, 조건 기반..
  * 경험 기반 테스트: 유사 소프트웨어나 기술 등에 대한 테스터 경험을 기반으로 수행하는 테스트. 에러 추정, 체크리스트, 탐색적 테스팅..

* 시각에 따른 분류
  * 검증 테스트: 개발자 시각에서 제품이 명세대로 완성됐는지 제품 생산 과정을 테스트.
  * 확인 테스트: 사용자 시각에서 요구사항이 만족되었는지 제품 생산 결과를 테스트.
* 목적에 따른 테스트
  * 회복(Recovery) 테스트: 시스템에 여러 결함을 줘 실패하도록 한 후 올바르게 복구되는지 테스트.
  * 안전(Security) 테스트: 시스템 보호 도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지 테스트.
  * 강도(Stress) 테스트: 과부하 시에도 정상 작동하는지 테스트.
  * 성능(Perfomance) 테스트: 응답시간, 처리량 등을 테스트.
  * 구조(Structure) 테스트: 논리적 경로, 소스 복잡도 등을 테스트.
  * 회귀(Regression) 테스트: 수정된 코드에 새로운 결함이 없는지 확인하는 테스트.
  * 병행(Parallel) 테스트: 변경된 것과 기존 것에 동일한 데이터를 입력해 결과를 비교하는 테스트.

---

### 63. 테스트 기법에 따른 애플리케이션 테스트 - A

* 화이트박스 테스트: 원시 코드를 오픈시킨 상태에서 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방식. 
  원시 코드의 모든 문장을 한 번 이상 수행.
  * 종류
    * 기초 경로 검사: 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법.
    * 제어 구조 검사
      * 조건 검사(모듈 내의 논리적 조건을 테스트)
      * 루프 검사(반복구조에 초점을 두고 테스트)
      * 데이터 흐름 검사(변수의 정의와 사용에 초점을 두고 테스트)
  * 검증 기준
    * 문장 검증 기준: 모든 구문이 수행되도록 설계
    * 분기 검증 기준: 모든 조건문이 수행되도록 설계
    * 조건 검증 기준: 모든 조건문이 True인 경우와 False인 경우가 수행되도록 설계
    * 분기/조건 기준: 모든 조건문과 각 조건문에 포함된 개별 조건식 결과가 True/False인 경우가 수행되도록 설계

* 블랙박스 테스트: 소프트웨어의 각 기능이 완전히 작동되는 것을 입증하는 테스트. 
  명세를 보면서 테스트하고 구현된 기능을 테스트함. 소프트웨어 인터페이스에서 실시.
  * 동치 분할 검사: 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 기법.
  * 경계값 분석: 입력 조건의 경계값을 테스트 케이스로 선정하여 검사.
  * 원인-효과 그래프 검사: 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석하여 효용성이 높은 테스트 케이스를 선정하는 기법.
  * 오류 예측 검사: 과거의 경험이나 확인자의 감각으로 테스트하는 기법.
  * 비교 검사: 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법.

---

### 64. 개발 단계에 따른 애플리케이션 테스트 - A

* 요구사항 → 분석 → 설계 → 구현 → 단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트
* 단위 테스트(Unit Test): 코딩 직후 모듈이나 컴포넌트에 중점을 맞춘 테스트.
  * 구조 기반 테스트: 프로그램 내부 구조 및 복잡도를 검증하는 화이트박스 테스트 시행.
  * 명세 기반 테스트: 목적 및 실행 코드 기반의 블랙박스 테스트 시행.
* 통합 테스트(Integration Test): 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성하는 과정의 테스트.
* 시스템 테스트: 개발된 소프트웨어가 해당 컴퓨터 환경에서 완벽하게  수행되는가를 점검하는 테스트.
* 인수 테스트(Acceptance Test): 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트. 사용자가 직접 테스트함.
  * 사용자 인수 테스트, 운영상 인수 테스트, 계약 인수 테스트, 규정 인수 테스트
  * 알파 테스트: 개발자 앞에서 행하는 테스트. 통제된 환경에서 행해지며 오류와 문제점을 사용자와 개발자가 함께 확인하며 기록.
  * 베타 테스트: 여러 명의 사용자 앞에서 행하는 테스트. 개발자에 의해 제어되지 않은 상태에서 행해지며 오류와 문제점을 기록하고 개발자에게 주기적으로 보고함.

---

### 65. 통합 테스트(Integration Test) - A

* 통합 테스트 방법
  * 비점진적 통합 방식: 모든 모듈이 결합된 프로그램 전체를 테스트. 빅뱅 통합 테스트.
  * 점진적 통합 방식: 모듈을 단계적으로 통합하며 테스트. 하향식, 상향식, 혼합식 통합 테스트.
* 하향식 통합 테스트(Top Down): 프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하며 테스트.
  * 깊이 우선 통합법과 넓이 우선 통합법이 있음. 
  * 주요 제어 모듈은 작성된 프로그램을, 종속 모듈들은 **스텁(Stub)**으로 대체함. 통합 방식에 따라 스텁이 하나씩 실제 모듈로 교체됨. 

* 상향식 통합 테스트(Bottom Up): 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하며 테스트. 
  * 하위 모듈들을 **클러스터(Cluster)**로 결합하고 상위 모듈은 데이터 입출력 확인을 위한 더미 모듈인 **드라이버(Driver)**를 작성.
  * 통합된 클러스터 단위로 테스트하고 테스트가 완료되면 클러스터는 프로그램 상위 구조로 이동, 드라이버는 실제 모듈로 대체됨.

* 혼합식 통합 테스트: 하위 수준에서 상향식, 상위 수준에서 하향식 테스트. 샌드위치식 통합 테스트.

* 각 통합 간에는 회귀 테스트를 시행함.

---

### 66. 애플리케이션 테스트 프로세스 - B

* 순서: 테스트 계획 → 테스트 분석 및 디자인 → 테스트 케이스 및 시나리오 작성 → 테스트 수행 → 테스트 결과 평가 및 리포팅 → 결함 추적 및 관리

---

### 67. 테스트 케이스 / 테스트 시나리오 / 테스트 오라클 - B

* 테스트 케이스: 구현된 소프트웨어가 사용자의 요구사항을 충족하는지 확인하기 위해 설계된 입력값, 실행조건, 기대결과 등으로 구성된 테스트 항목에 대한 명세서.
* 테스트 시나리오: 여러 테스트 케이스를 적용 순서에 따라 묶은 집합.
* 테스트 오라클: 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참값을 대입하여 비교하는 기법.
  * 참 오라클: 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클. 
  * 샘플링 오라클: 특정 몇몇 테스트 케이스의 입력 값에 대해서만 기대하는 결과를 제공하는 오라클.
  * 추정 오라클: 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클.
  * 일관성 검사 오라클: 애플리케이션 변경이 있을 때 테스트 케이스 수행 전후의 결과값이 동일한지 확인하는 오라클.

---

### 68. 테스트 자동화 도구 - B

* 테스트 자동화 도구를 사용함으로써 휴먼 에러를 줄이고 테스트의 정확성을 유지하면서 테스트의 품질을 향상시킬 수 있음.
* 유형
  * 정적 분석 도구: 프로그램을 실행하지 않고 분석하는 도구.
  * 테스트 실행 도구: 스크립트 언어를 사용하여 테스트를 실행하는 방법.
  * 성능 테스트 도구: 애플리케이션 처리량, 응답 시간, 경과 시간, 자원 사용률 등을 인위적으로 적용한 가상의 사용자를 만들어 테스트를 수행.
  * 테스트 통제 도구: 테스트 계획 및 관리, 테스트 수행, 결함 관리 등을 수행하는 도구. (형상관리도구, 결함 추적/관리 도구..)
  * 테스트 하네스 도구: 테스트가 실행될 환경을 시뮬레이션하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구. 
    * 구성요소: 테스트 드라이버, 테스트 스텁, 테스트 슈트(테스트 케이스의 집합), 테스트 케이스, 테스트 스크립트(자동화 테스트 실행 절차에 대한 명세서), 목 오브젝트(사전 행위 입력 시 예정된 행위를 하는 객체)

---

### 69. 결함 관리 - B

* 결함(Fault): 오류 발생, 작동 실패 등 소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 것.
* 결함 관리 프로세스
  * 결함 관리 계획 → 결함 기록 → 결함 검토 → 결함 수정 → 결함 재확인 → 결함 상태 추적 및 모니터링 활동 → 최종 결함 분석 및 보고서 작성
* 결함 관리 측정 지표
  * 결함 분포: 모듈 또는 컴포넌트의 특정 속성에 해당하는 결함 수 측정
  * 결함 추세: 테스트 진행 시간에 따른 결함 수의 추이 분석
  * 결함 에이징: 특정 결함 상태로 지속되는 시간 측정
* 결함 추적 순서: 등록(Open) → 검토(Reviewed) → 할당(Assigned) → 수정(Resolved) → 종료(Closed) → 해제(Clarified)

---

### 70. 애플리케이션 성능 분석 - C

* 성능 측정 지표
  * 처리량(Throughput): 일정 시간 내에 처리하는 일의 양
  * 응답 시간(Response Time): 요청을 전달~응답 도착까지의 시간
  * 경과 시간(Turn Around Time): 작업 의뢰~처리 완료까지의 시간
  * 자원 사용률(Resource Usage): 작업 처리 동안 CPU, 메모리, 네트워크 사용량 등
* 성능 테스트 도구: 애플리케이션에 부하나 스트레스를 가하며 성능 측정 지표를 점검.
* 시스템 모니터링 도구: 시스템 자원의 사용량을 확인하고 분석하는 도구.

* 분석 절차
  1. 도구 유형 파악, 특징 정리
  2. 점검 계획서 작성
  3. 테스트 케이스 작성
  4. 테스트 수행
  5. 결과 분석
  6. 성능 저하 요인 분석

---

### 71. 애플리케이션 성능 개선 - C

* 소스 코드 최적화: 나쁜 코드를 배제하고 클린 코드로 작성.
  * 클린 코드: 누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순명료한 코드.
    * 가독성, 단순성, 의존성배제, 중복성최소화, 추상화
  * 나쁜 코드: 스파게티 코드 등 프로그램 로직이 복잡하고 이해하기 어려운 코드.

* 소스 코드 최적화 유형
  * 클래스 분할 배치: 한 클래스는 하나의 역할만 수행하도록 응집도 높이고 크기를 작게 작성
  * Loosly Coupled(느슨한 결합): 인터페이스 클래스를 이용해 추상화된 자료구조와 메소드를 구현하여 클래스 간 의존성을 최소화
  * 팩토리 메소드 패턴: 상위 클래스에서 객체 생성하는 인터페이스를 정의하고 하위 클래스에서 실제 객체를 만드는 방식. (생성과 사용을 분리)
  * 코딩 형식 준수: 줄바꿈, 개념적 유사성 높은 종속 함수 사용, 호출하는 함수는 선배치, 호출되는 함수는 후배치, 지역 변수는 각 함수의 맨 처음에 사용 등
  * 좋은 이름 사용(명명규칙), 적절한 주석문 사용



