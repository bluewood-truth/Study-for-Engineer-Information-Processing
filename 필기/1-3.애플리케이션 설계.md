### 20. 소프트웨어 아키텍처 - A

* 소프트웨어 아키텍처: 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 기본 구조.
  * 이해관계자들의 의사소통 도구로 활용.
  * 비기능적 요구사항의 제약을 반영하며 기능적 요구사항을 구현.
  * 애플리케이션을 모듈별로 분할해 기능을 할당하고 모듈간 인터페이스 결정.
  * 기본 원리: **모듈화, 추상화, 단계적 분해, 정보은닉**
* **모듈화**: 성능향상, 수정 및 재사용, 유지 관리 등을 위해 시스템의 기능을 모듈별로 분할.
* **추상화**: 포괄적 개념 설계 -> 이후 차례로 세분화하여 구체화.
  * 과정 추상화(구체적인 수행 과정을 추상화), 데이터 추상화(데이터의 세부적 속성이나 용도를 추상화), 제어 추상화(이벤트 발생의 절차나 방법을 추상화)
* **단계적 분해**: 중요 개념 -> 하위 개념으로 구체화. 추상화의 반복에 의해 세분화됨. 
  * 소프트웨어 기능 -> 알고리즘, 자료구조 등..
* **정보 은닉**: 모듈의 캡슐화 (필요한 정보만 인터페이스로 주고받음)
* 소프트웨어 아키텍처 품질 속성
  * **시스템 측면**: **성능**, **보안**, **가용성**(장애 없이 정상적인 서비스), **기능성**(사용자가 요구한 기능 구현), **사용성**(사용자가 헤메지 않도록), **변경 용이성**(다른 하드웨어나 플랫폼에서도), **확장성**, 기타 속성(테스트용이성, 배치성, 안정성)
  * **비즈니스 측면**: **시장 적시성**(기한에 맞게 출시), **비용과 혜택**, **예상 수명 시스템**(길어야 한다면 변경용이성, 확장성 고려), 기타 속성(목표시장, 공개일정, 기존 시스템과 통합)
  * **아키텍처 측면**: **개념적 무결성**(전체 요소의 일관성), **정확성&완결성**, **구축 가능성**(적절한 분배->유연한 일정 변경), 기타 속성(변경성, 시험성, 적응성, 일치성, 대체성) 

* 소프트웨어 아키텍처 설계 과정
  1. 설계 목표 설정
  2. 시스템 타입 설정: 시스템과 서브시스템 타입 결정.
     * 대화형(요청->처리. 대부분의 웹), 이벤트 중심(전화, 비상벨 등), 변환형(입력->처리 후 출력. 컴파일러, 네트워크 프로토콜 등), 객체 영속형(db를 사용해 파일을 저장, 검색, 갱신. 서버 관리 소프트웨어 등)
  3. 아키텍처 패턴 적용
  4. 서브시스템 구체화
  5. 검토

<br>

### 21. 아키텍처 패턴 - A

* **레이어 패턴**: 각 서브시스템들이 계층 구조를 이루고 상위계층은 서비스 제공자, 하위계층은 클라이언트가 됨.
  * 서로 마주본 두 계층 간에만 상호작용이 발생. 특정 계층만 변경도 가능.
  * 대표적으로 **OSI 참조 모델**.
* **클라이언트-서버 패턴**: 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성
  * 사용자는 클라이언트와만 의사소통. 요청 -> 응답. (서버는 항상 대기)
  * 서버와 클라이언트는 요청-응답을 위해 동기화되는 경우를 제외하면 서로 독립적.
* **파이프-필터 패턴**: 데이터 스트림의 각 단계를 필터 컴포넌트로 캡슐화.
  * 필터는 재사용성이 좋고 확장 용이. 필터 컴포넌트의 배치에 따라 다양한 파이프라인 구축.
  * **데이터변환, 버퍼링, 동기화** 등에 자주 사용. 대표적으로 UNIX의 Shell이 있음.
* **모델-뷰-컨트롤러 패턴**: 모델(핵심 기능과 데이터) + 뷰(사용자에게 정보 표시) + 컨트롤러(사용자 입력 처리)
  * 모델, 뷰, 컨트롤러 컴포넌트는 서로 독립적.
  * 한 패턴에 여러 뷰 가능 -> **대화형 애플리케이션**에 적합.

* 기타 패턴
  * 마스터-슬레이브 패턴: 마스터->슬레이브로 작업 분할 후 슬레이브의 결과물을 마스터가 받음.
    * **장애 허용 시스템, 병렬 컴퓨팅**
  * 브로커 패턴: **분산 환경 시스템.**
  * 피어-투-피어 패턴: 각 피어는 클라이언트가 될 수도, 서버가 될 수도 있음. 멀티스레딩 방식.
  * 이벤트-버스 패턴: 소스가 이벤트 메세지를 발행하면 해당 채널을 구독한 리스너들이 이벤트 처리.
  * 블랙보드 패턴: 모든 컴포넌트가 블랙보드 컴포넌트에 접근 가능.
    * **음성인식, 차량식별, 신호 해석**
  * 인터프리터 패턴

<br>

### 22. 객체지향 - A

* **객체**: 데이터 + 함수. 한 클래스에 속하는 인스턴스.
* **클래스**: 객체의 타입. 인스턴스화로 객체 생성. 슈퍼클래스(부모), 서브클래스(자식), 최상위클래스(부모없음)
* **캡슐화**: 객체간 결합 낮아짐. 재사용 용이.
* **상속**: 부모의 속성을 물려받음. 다중 상속도 가능.
* **다형성**: 같은 메세지라도 클래스에 따라 다른 처리를 함.

<br>

### 23. 모듈 - A

* 모듈: 서브시스템 등 모듈화로 분리된 시스템의 각 기능. 단독으로 컴파일 가능.
  * 모듈의 독립성을 높이려면 모듈의 결합도↓, 응집도↑, 모듈 크기↓
* **결합도(Coupling)**: 모듈 간 상호 의존 정도. 결합도가 낮을수록 품질 높음. (아래로 갈수록 결합도↑)
  * **데이터 결합도(Data)**: 모듈 간에 호출할 때 인수를 넘겨주고 결과값을 받음. 가장 바람직.
  * **스탬프 결합도(Stamp)**: 모듈 간의 인터페이스로 배열이나 레코드 등을 전달.
  * **제어 결합도(Control)**: 한 모듈이 다른 모듈의 논리적 흐름을 제어함.  하위모듈이 상위모듈을 제어하는 권리 전도현상 발생.
  * **외부 결합도(External)**: 한 모듈에서 선언한 변수를 다른 모듈에서 참조.
  * **공통(공유) 결합도(Common)**: 공통 데이터 영역을 여러 모듈이 사용. 
  * **내용 결합도(Content)**: 한 모듈이 다른 모듈의 내부 기능 및 자료를 직접 참조하거나 수정. 혹은 모듈간 제어의 이동.
* **응집도(Cohesion)**: 모듈의 내부 요소들이 서로 관련있는 정도. 응집도가 강할수록 품질이 높음. (아래로 갈수록 응집도↓)
  * **기능적 응집도(Functional)**: 모듈 내 모든 요소가 단일 문제와 연관되어 수행.
  * **순차적 응집도(Sequential)**: 모듈 내 하나의 활동으로 나온 출력을 그 다음 활동의 입력으로 사용.
  * **교환(통신)적 응집도(Communication)**: 동일한 입출력을 사용해 서로 다른 기능을 수행하는 요소들이 모였을 경우.
  * **절차적 응집도(Procedural)**: 모듈이 여러 관련 기능을 가질 때 모듈 안의 요소들이 그 기능을 순차적으로 수행.
  * **시간적 응집도(Temporal)**: 특정 시간에 처리되는 기능들을 모아 모듈을 형성.
  * **논리적 응집도(Logical)**: 유사한 성격의 요소들을 모아 모듈을 형성.
  * **우연적 응집도(Coincidental)**: 모듈 내 요소들이 서로 관련이 없음.
* **팬인 / 팬아웃**: 어떤 모듈이 호출되는 / 호출하는 모듈의 수.
  * 시스템 복잡도를 최적화하려면 팬인은 높게, 팬아웃은 낮게 설계해야 함.

<br>

### 24. 공통 모듈 - C

* 공통 모듈: 여러 프로그램에서 사용될 수 있는 모듈. 공통 모듈 명세서는 다음의 요소가 포함:
  * 정확성(Correctness): 시스템 구현 시 해당 기능이 필요하다는걸 정확히 작성
  * 명확성(Clarity): 해당 기능을 명확히 작성
  * 완전성(Completeness): 구현을 위해 필요한 모든 것을 작성
  * 일관성(Consistency): 공통 기능 간 상호 충돌이 없게 작성
  * 추적성(Traceability): 기능에 대한 요구사항, 관련 시스템 등을 파악 가능하게 작성.
* 재사용: 재사용되는 모듈은 결합도는 낮고 응집도는 높아야 함.
  * 함수와 객체: 클래스나 메소드 단위 소스코드를 재사용.
  * 컴포넌트: 컴포넌트 수정은 없이 인터페이스를 통해 통신.
  * 애플리케이션: 공통 기능을 제공하는 애플리케이션을 공유.

<br>

### 25. 코드 - B

* 기능
  * **식별, 분류, 배열**
* 종류
  * 순차 코드: 순서대로 숫자 부여
  * 블록 코드: 공통성이 있는 것끼리 블록을 부여해 블록 내에서 순차적으로 숫자 부여
  * 10진 코드: 10자리 단위마다 분류. 도서 분류식 코드. (ex. 1000=공학, 1100=소프트웨어공학, 1110=소프트웨어설계)
  * 그룹 분류 코드: 대분류, 중분류, 소분류 등으로 구분하여 일련번호 부여
  * 연상 코드: 약칭, 기호, 연관된 숫자 등으로 코드 부여
  * 표의 숫자 코드: 대상의 길이, 넓이 등 실제 수치를 코드에 적용
  * 합성 코드

<br>

### 26. 디자인 패턴 - B

* **생성 패턴(Creational)**
  * **Abstract Factory**: 인터페이스를 통해 서로 연관된 객체들의 그룹으로 생성.
  * **Builder**: 작은 인스턴스들을 조합하여 객체 생성. 객체 생성과 표현 과정을 분리 -> 동일한 객체 생성에도 다른 결과 가능.
  * **Factory Method**: 상위 클래스에서 인터페이스만 정의 -> 서브 클래스에서 객체 생성.
  * **Prototype**: 원본 객체를 복제. 비용이 큰 경우 주로 이용.
  * **Singleton**: 클래스 내 인스턴스를 단 하나만 생성하여 여러 곳에서 사용.
* **구조 패턴(Structural)**
  * **Adapter**: 호환성이 없는 인터페이스를 다른 클래스가 사용가능하도록 변환.
  * **Bridge**: 기능과 구현을 별도 클래스로 분리 -> 서로가 독립적으로 확장 가능.
  * **Composite**: 객체들을 트리 구조의 복합 클래스로 구성. 복합 in 복합도 가능.
  * **Decorator**: 임의의 객체에 부가적인 기능을 가진 다른 객체를 덧붙여서 확장.
  * **Facade**: 상위에 인터페이스를 구성해 서브클래스를 간편하게 사용.
  * **Flyweight**: 인스턴스를 매번 생성하지 말고 한번 생성한걸 가능한 한 공유.
  * **Proxy**: 접근이 어려운 객체와 다른 객체간 인터페이스 역할.
* **행위 패턴(Behavioral)**
  * **Chain of Responsibility**: 요청을 처리하는 객체가 여럿 존재하여 한 객체가 처리를 못하면 다음 객체로 넘어감.
  * **Command**: 요청을 객체화하여 저장하거나 로그에 남김.
  * **Interpreter**: 다른 언어 사용.
  * **Iterator**: 접근이 잦은 객체에 동일한 인터페이스를 사용.
  * **Mediator**: 객체 간 복잡한 상호작용을 객체화. 결합도를 감소시킴.
  * **Memento**: 특정 시점의 객체 내부를 객체화하여 되돌리기 가능. Ctrl+Z등을 구현할때 사용.
  * **Observer**: 한 객체의 상태가 변화하면 상속된 다른 객체에게 전달. 분산된 시스템 간에 이벤트 생성하고 수신할 때 사용.
  * **State**: 객체의 상태에 따라 동일한 동작을 다르게 처리.
  * **Strategy**: 동일 계열 알고리즘을 개별적으로 캡슐화하여 클라이언트는 원하는 알고리즘 선택.
  * **Template Method**: 상위 클래스에서 골격을 정의하고 하위 클래스에서 내부 구현.
  * **Visitor**:각 클래스에서 처리 기능을 분리하여 별도의 클래스로 구성. 처리 기능은 각 클래스를 방문하여 수행.